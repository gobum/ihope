#!/usr/bin/env node

/** -------------------------------------------------------------------------------------------------------------------
 * it
 *  Usage:
 *    it [-<agent>] [page.html] test.js [ ... tests.js]
 */

//const CLI = 1

const macro = function(){
/** -------------------------------------------------------------------------------------------------------------------
 * lib.js
 */

/**
 * get(path)
 *  获取指定路径的文本数据
 */
var get = function(fs){
  if(this.window) {
    fs = new XMLHttpRequest;
    return function(path){
      fs.open('GET', path, false);
      fs.send();
      if(!(fs.status / 100 ^ 2))
        return fs.responseText;
    }
  }
  else {
    fs = require('fs');
    return function(path) {
      return fs.readFileSync(path).toString();
    }
  }
}();

/**
 * repath(path, rel)
 *  计算相对路径
 */
var repath = function(path, rel){
  var rePath = /^(https?:\/\/[\w-.]+(?::\d+)?|)([\w\/.-]+)(.*|)/;
  var reRel = /^(https?:\/\/[\w-.]+(?::\d+)?|)(\/(?:[\w@.-]+\/)*)/;

  function repath(path, rel) {
    var ms = path.match(rePath);
    if (ms && !ms[1] && rel && (rel = rel.match(reRel))) {
      path = ms[2];
      if (path[0] !== '/') {
        path = rel[2] + path;
      }
      path = rel[1] + normalize(path) + ms[3];
    }
    return path;
  }

  /** normalize(path) 路径规格化 */
  var reSlash = /\/+/;

  function normalize(src) {
    var des = [];
    src = src.split(reSlash);
    for (var i = 0, l = src.length; i < l; i++) {
      var sym = src[i];
      if (des.length) {
        if (sym !== '.') {
          var end = des[des.length - 1];
          if (sym !== '..') {
            if (end === '.' && sym) des.length--;
            des.push(sym);
          }
          else if (end === '..') {
            des.push(sym);
          }
          else if (end) {
            des.length--;
          }
        }
      }
      else {
        des.push(sym);
      }
    }
    return des.join('/');
  }

  return repath;

}();

var libpath = this.window || function(){
  var fs = require("fs");
  var reLibName = /^(?:@[a-z0-9-][a-z0-9-._]*\/)?[a-z0-9-][a-z0-9-._]*(\/[^]*)?/;

  function libpath(name, rel) {
    var ms = name.match(reLibName);
    if (!ms)
      throw Error("Error libaray name: '" + name + "'");
    if(!ms[1]) {
      name += "/all.js";
    }
    else if(!name.endsWith(".js")) {
      name += ".js";
    }
  
    var rel = dirname(rel);
    while (rel) {
      var tryname = rel + "node_modules/" + name;
      if (fs.existsSync(tryname))
        return tryname;
      rel = dirname(rel.slice(0, -1));
    }

    rel = process.env.NODE_PATH;
    if (rel) {
      rel = rel.split(":");
      for (var i = 0; i < rel.length; i++) {
        var dir = rel[i];
        if (dir) {
          tryname = dir + "/" + name;
          if (fs.existsSync(tryname))
            return tryname;
        }
      }
    }
    throw Error("Can't find libaray :'"+name+"'");
  }
  
  function dirname(path) {
    return path.slice(0, path.lastIndexOf("/") + 1);
  }
  return libpath;  
}();

function isLibName(name) {
  return /^[^./]/.test(name);
}

function incpath(path, rel) {
  if(isLibName(path))
    return libpath(path, rel);
  return repath(path, rel);
}
/** -------------------------------------------------------------------------------------------------------------------
 * lex.js
 */

const Lex = function () {
  function $() { return arguments };

  function regular(any, keys) {
    if (any instanceof Object) {
      if (any instanceof RegExp) {
        any = any.source;
      }
      else if (any.length) {
        var arg = [];
        for (var i = 0; i < any.length; i++)
          arg[i] = regular(any[i], keys);
        // any = arg.join(any.join ? '' : '|');
        if (any.join) {
          any = arg.join('');
        }
        else {
          any = arg.join('|');
          if (arg.length > 1)
            any = '(?:' + any + ')';
        }
      }
      else {
        arg = String(Object.keys(any));
        keys[arg] = keys.$ = (keys.$ | 0) + 1;
        any = '(' + regular(any[arg], keys) + ')';
      }
    }
    else {
      any = String(any);
    }
    return any;
  }

  var keys = Object.create(null);
  var lex = regular($(
    { IF: [/\/\/#if\s*\(/, { COND: /[^)]+/ }, /\)\s*{.*\n?/] },
    { END: /\/\/#}.*\n?/ },
    { INCLUDE: [/\/\/#include\s+/, { FILE: /\S+/ }, /.*/] },
    { DEFINE: [/\/\/#define\s+/, { DID: /[a-zA-Z_$][\w$]*/ }, /\s*/, $([/@\s*/, { RES: /\S+/ }, /.*/], [/=\s*/, { EXP: /.+/ }], { VAL: /.+/ })] },
    { VAR: [/\/\/#var\s+/, { VID: /[a-zA-Z_$][\w$]*/ }, /\s*=\s*/, { VEXP: /.+/ }] },
    { TEMP_HEAD: [/`(?:[^`$\\]+|\$(?!{)|\\[^])*/, $(/`|$/, { TEMP_OPEN: /\${/ })] },  //模板头（容错）
    { TEMP_TAIL: [/}(?:[^`$\\]+|\$(?!{)|\\[^])*/, $(/\${/, { TEMP_CLOSE: /`|$/ })] },  //模板尾（容错）
    { BLOCK_HEAD: /\{/ },
    { BLOCK_TAIL: /\}/ },
    { FUNC: /(?:async\s+)?function\b[^(]*\([^)]*\)/ },
    { ARROW: /(?:\([^)]*\)|[a-zA-Z_$][\w$]*)\s*=>/ },
    { ID: /[a-zA-Z_$][\w$]*/ },
    { SQ: /'(?:[^'\n\\]+|\\[^])*(?:['\n]|$)/ },  // 单引号字符串（容错）
    { DQ: /"(?:[^"\n\\]+|\\[^])*(?:["\n]|$)/ },  // 双引号字符串（容错）
    { REGEXP: /\/(?:\\.|\[(?:\\.|[^\]])*\]|[^\/\*\n\r])(?:\\.|\[(?:\\.|[^\]])*\]|[^/\n\r])*?\/[gimy]*/ },
    { COMMENT: /\/\/.*|\/\*[^*]*\*+(?:[^/][^*]*\*+)*\// },
    { OTHER: /(?:[^{}a-zA-Z_$'"`/]|\/(?![/*]))+/ },
    { SPECIAL: /\// }
  ), keys);

  lex = RegExp(lex + '|', 'g');
  Lex.$ = keys;

  function Lex(code) {
    var $ = keys, re = new RegExp(lex), stack = [], state = 0;
    return function () {
      var ms;
      if (ms = re.exec(code)) {
        if (ms[$.BLOCK_HEAD]) {
          stack.push(state);
          state = $.BLOCK_HEAD;
        }
        else if (ms[$.TEMP_HEAD]) {
          stack.push(state);
          state = $.TEMP_HEAD;
        }
        else if (ms[$.TEMP_TAIL]) {
          if (state === $.BLOCK_HEAD) {
            ms[0] = ms[$.BLOCK_TAIL] = "}";
            ms[$.TEMP_TAIL] = ms[$.TEMP_CLOSE] = undefined;
            re.lastIndex = ms.index + 1;
            state = stack.pop();
          }
          else if (ms[$.TEMP_CLOSE] && state === $.TEMP_HEAD) {
            state = stack.pop();
          }
        }
        else if (ms[$.BLOCK_TAIL]) {
          if (state = $.BLOCK_HEAD) {
            state = stack.pop();
          }
        }
      }
      return ms;
    }
  }

  return Lex;
}();


/** -------------------------------------------------------------------------------------------------------------------
 * make.js
 */

/**
 * make(path, rel)
 */
var makeFile = function (calc) {
  calc = this.eval("(function(){with(arguments[0])return eval(arguments[1])})");

  function makeFile(path, rel, includes, defines, variables, indent) {
    var code;
    path = incpath(path, rel);
    if (includes[path]) {
      code = '';
    }
    else {
      includes[path] = 1;    // 占位符，防止无限递归
      code = get(path);
      if (code)
        try {
          code = makeCode(code, path, includes, defines, variables, indent);
        }
        catch (e) {
          if (e instanceof MacroError)
            e = Error(e.message + ' at (' + path + ':' + rowcol(code, e.index) + ')');
          throw e;
        }
    }
    return code;
  }

  function makeCode(code, rel, includes, defines, variables, indent) {
    var lex = Lex(code), $ = Lex.$, token, codes = [], id, it;
    var skip = 0;
    while (token = lex()) {
      var s = token[0];
      if (!s) {
        if (token.index < code.length)
          throw new MacroError('Unknown token', token.index);
        break;
      }

      if (token[$.IF]) {
        if (skip) {
          skip++;
        }
        else {
          it = token[$.COND];
          try {
            if (!calc(variables, it))
              skip = 1;
          }
          catch (e) {
            skip = 1;
          }
        }
        continue;
      }
      if (token[$.END]) {
        if(skip>0)
          skip --;
        continue;
      }
      if (skip) continue;

      if (token[$.INCLUDE]) {
        var file = token[$.FILE];
        // if (file = makeFile(file, rel, includes, defines, variables, indentOf(code, token.index)))
        //   s = file;
        s = makeFile(file, rel, includes, defines, variables, indentOf(code, token.index));
      }
      else if (token[$.DEFINE]) {
        id = token[$.DID];
        if (it = token[$.VAL]) {
          it = it.trim();
        }
        else if (it = token[$.RES]) {
          it = repath(it, rel);
          try {
            s = get(it);
            if (s === undefined)
              throw Error("Read file error: " + it);
          }
          catch (e) {
            throw new MacroError(e.message, token.index);
          }
          it = JSON.stringify(s);
        }
        else if (it = token[$.EXP]) {
          it = calc(variables, it);
        }
        defines[id] = variables[id] = it;
        s = "//const " + id + " = " + String(it);
      }
      else if (token[$.VAR]) {
        id = token[$.VID];
        it = token[$.VEXP];
        it = calc(variables, it);
        variables[id] = it;
        s = "//var " + id + " = " + String(it);
      }
      else if (id = token[$.ID]) {
        if (id in defines) {
          s = "/*" + id + "*/" + String(defines[id]);
        }
      }
      else if (token[$.BLOCK_HEAD]) {
        includes = Object.create(includes);
        defines = Object.create(defines);
      }
      else if (token[$.BLOCK_TAIL]) {
        var proto = Object.getPrototypeOf(defines);
        if (proto) defines = proto;
        var proto = Object.getPrototypeOf(includes);
        if (proto) includes = proto;
      }
      codes[codes.length] = s;
    }
    code = codes.join('');
    code = code.replace(/^/gm, indent).slice(indent.length);
    return code;
  }

  function MacroError(message, index) {
    this.message = message;
    this.index = index;
  }

  function indentOf(text, index) {
    for (var i = index; ' \t'.indexOf(text[i - 1]) >= 0; i--);
    return text.slice(i, index);
  }

  /**
   * rowcol(text, i)
   *   计算文本 text 位置 i 的行列值。返回格式 "row:col"
   */
  function rowcol(text, index) {
    if (index < 0) return '<EOF>';
    var reLn = /[\n\u2028\u2029]|\r\n?/g;
    var row = 0, col = 0;
    while (reLn.exec(text) && index > reLn.lastIndex) {
      row++;
      col = reLn.lastIndex;
    }
    col = index - col;
    return (row + 1) + ':' + (col + 1);
  }

  return makeFile;
}();


return function (path, base, variables) {
  return makeFile(path, base, Object.create(null), Object.create(null), variables || Object.create(null), "");
}
}();

/** -----------------------------------------------------------------------------------------------
 * lib.js
 */

var undefined;

/** --------------------------------------------------------------------------
 * Function
 */
var nop = Function.prototype;
var _call = nop.call;
var _apply = nop.apply;
var _bind = nop.bind;
var func = _call.bind(_bind, _call);
var bind = func(_bind);
var call = func(_call);
var apply = func(_apply);

function isFunction(any) {
  return typeof any === 'function';
}

  /** --------------------------------------------------------------------------
   * Object
   */
  var Object_prototype = Object.prototype;
  var create = Object.create;
  var getPrototype = Object.getPrototypeOf;
  var setPrototype = Object.setPrototypeOf;
  var _isPrototypeOf = Object_prototype.isPrototypeOf;

  function isObject(any) {
    return Object(any) === any;    // typeof any === 'object' && any !== nil;
  }

  function genusof(any) {
    return any === null ? "null" : typeof any;
  }

  var reTrimTag = /\[object |\]/g;
  function tagof(any) {
    return replace(call(Object_prototype.toString, any), reTrimTag, '');
  }

  var hasOwnProperty = func(Object_prototype.hasOwnProperty);
  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

  function hasProperty(obj, prop) {
    while (obj) {
      if (hasOwnProperty(obj, prop))
        return obj;
      obj = getPrototype(obj);
    }
  }

  function getPropertyDescriptor(obj, prop) {
    var desc;
    while (obj) {
      if (desc = getOwnPropertyDescriptor(obj, prop))
        return desc;
      obj = getPrototype(obj);
    }
  }

  /** --------------------------------------------------------------------------
   * String
   */
  var String_prototype = String.prototype;

  function isString(any) {
    return typeof any === 'string';
  }

  var trim = func(String_prototype.trim);
  var replace = func(String_prototype.replace);
  var match = func(String_prototype.match);
  var split = func(String_prototype.split);
  var stringify = JSON.stringify;

  /** --------------------------------------------------------------------------
   * Array
   */
  var Array_prototype = Array.prototype;
  var piece = func(Array_prototype.slice);
  var splice = func(Array_prototype.splice);
  var push = func(Array_prototype.push);
  var pop = func(Array_prototype.pop);

  /** --------------------------------------------------------------------------
   * RegExp
   */
  function isRegExp(any) {
    return any instanceof RegExp;
  }

  /** --------------------------------------------------------------------------
   * Date
   */
  var now = Date.now;

  /** --------------------------------------------------------------------------
   * Iterator, Promise, Generator, Async Function
   */
  var isIterator = bind(_isPrototypeOf, getPrototype(getPrototype(''[Symbol.iterator]())));
  var isPromise = bind(_isPrototypeOf, Promise.prototype);

  function isGeneratorFunction(any) {
    return tagof(any) === 'GeneratorFunction';
  }

  function isAsyncFunction(any) {
    return tagof(any) === 'AsyncFunction';
  }

  function isSyncFunction(any) {
    return tagof(any) === 'Function';
  }

  /** indent(code, spaces) 缩进代码行 */
  function indent(code, spaces) {
    return code.replace(/^/gm, spaces);
  }


/** -----------------------------------------------------------------------------------------------
 * log.js
 */

function report(it) {
  if (!(it.end = it.parent.end)) {
    var s = it.topic;
    if (it.ms) {
      s += format(" (timeout #m%dms)", it.ms);
    }
    if (it.fail) {
      s = format("#f✘ %s\n#e%s%s", s, indent(it.fail, "  "), it.trace ? "\n" + indent(it.trace, "  #m") : "");
    }
    else {
      s = format("#s✔ %s", s);
    }
    log("%s", indent(s, it.indent));
    it.end = 1;
  }
}

function review() {
  var me = this, it = me.its[me.its.length - 1];
  if (it && !it.func && !it.end) {
    var s = '#t• ' + it.topic;
    if (it.trace)
      s += indent('\n#e' + it.trace, '  ');
    log(indent(s, it.indent));
  }
}

function log() {
  print(format.apply(undefined, arguments));
}

function print(s) {
  console.log(textcolor(s));
}

const textcolors = {
  0: "\x1b[0m",
  i: "\u001b[0m\u001b[37m",
  s: "\u001b[1m\u001b[32m",
  f: "\u001b[1m\u001b[31m",
  e: "\u001b[0m\u001b[31m",
  t: "\u001b[1m\u001b[34m",
  m: "\u001b[1m\u001b[30m"
};

function textcolor(text) {
  return replace(text, /#[sftiem]/g, (s) => textcolors[s[1]] || textcolors[0]) + textcolors[0];
}

const argscolors = {
  0: "",
  i: "color:lightgray",
  s: "color:lawngreen;font-weight:900",
  f: "color:tomato;font-weight:900",
  e: "color:red",
  t: "color:royalblue;font-weight:900",
  m: "color:darkgrey"
};

function argscolor(args) {
  var i = 1;
  args[0] = replace(args[0], /#\w/g, (s) => (args[i++] = argscolors[s[1]] || "", "%c"));
  args.length = i;
  return args;
}

function format(s) {
  var i = 1, args = arguments;
  return replace(s, /%[sd]/g, function (s) {
    return i < args.length ? args[i++] : s;
  });
}

/** -----------------------------------------------------------------------------------------------
 * trace.js
 */

/** get(path) 获取文本资源 */
var get;

if (this.window) {
  get = function (path) {
    var http = new XMLHttpRequest;
    http.open('GET', path, false);
    http.send();
    return http.status / 100 ^ 2 ? '' : http.responseText;
  };
}
else {
  const fs = require('fs');
  get = function (path) {
    return fs.readFileSync(path, { encoding: 'utf-8' });
  };
}

var reWhere = RegExp('\\b' + where.name + '\\b');
var reHere = /((?:https?:\/\/[\w.-]+(?::\d+)?|)[\w./@-]+(?:\?.*|)):(\d+):(\d+)/;
function where(deep) {
  var stack = split(Error().stack, "\n");
  for (var i = 0, line; line = stack[i++];) {
    if (match(line, reWhere)) break;
  }
  if (i < stack.length) {
    var ms = match(stack[i + deep], reHere);
    if (ms)
      return {
        trace: ms[0],
        loc: ms[1],
        row: ms[2] - 1,
        col: ms[3] - 1
      };
  }
}

var reTrace = /((?:https?:\/\/[\w.-]+(?::\d+)?|)[\w./@-]+(?:\?.*|)):(\d+):(\d+)/;
function getTrace(error) {
  var stack = error.stack;
  if (stack) {
    stack = split(stack, "\n");
    for (var i = 0, item; item = stack[i++];) {
      var ms = match(item, reTrace);
      if (ms) return ms[0];
    }
  }
}

function getLine(deep) {
  var here, rows, row;
  deep += 1;
  if (here = where(deep)) {
    if (rows = getRows(here.loc)) {
      if (row = rows[here.row]) {
        return { code: row, trace: here.trace }
      }
    }
  }
}

var cachedRows = {};
function getRows(loc) {
  var rows;
  if (hasOwnProperty(cachedRows, loc)) {
    rows = cachedRows[loc];
  }
  else {
    rows = cachedRows[loc] = split(get(loc), "\n");
  }
  return rows;
}



/** -----------------------------------------------------------------------------------------------
 * assert.js
 */
const EPSILON = 0.0000001192092896;

function assert(assert) {
  var it = newIt(this);
  if (!assert)
    it.fail = 'Assert failure!';
  report(it);
}

function hope(value) {
  var it = newIt(this, "", value);
  if (arguments.length > 1)
    it.args = piece(arguments, 1);
  return it;
}

function newIt(parent, topic, value) {
  call(review, parent);
  var it = create(itProto);
  it.parent = parent;
  var line = getLine(2), code;
  if (line) {
    code = trim(line.code);
    it.trace = line.trace;
  }
  it.topic = topic || code || "unknown testing"
  it.value = value;
  it.indent = parent.indent;
  it.zero = now();
  push(parent.its, it);
  return it;
}

var itProto = {
  get be() { return this },
  get is() {
    var me = this;
    var is = setPrototype(newIs(me), newA(me));
    return setPrototype({ get not() { me.no = 1; return is } }, is);
  },
  get not() {
    this.no = !this.no;
    return this;
  },

  equal: function (expect) { assertEqual(this, normalEqual, 'equals', expect) },

  get strict() {
    var me = this;
    return {
      equal: function (expect) { assertEqual(me, strictEqual, 'strict equals', expect) }
    }
  },

  get deep() {
    var me = this;
    return {
      equal: function (expect) { assertDeepEqual(me, normalEqual, 'deep equals', expect) },
      get strict() {
        return {
          equal: function (expect) { assertDeepEqual(me, strictEqual, 'deep strict equals', expect) }
        }
      }
    }
  },

  get a() { return newA(this) },

  get has() {
    var me = this;
    var has = newHas(me);
    return setPrototype({ get not() { me.no = 1; return has }, get no() { me.no = 1; return has } }, has);
  },
  throw: function () {
    var me = this, value = me.value, args = arguments, specified, error;
    if (specified = args.length) error = args[0];
    args = me.args;
    if (assertFunction(me)) {
      if (isSyncFunction(value)) {
        try {
          apply(value, undefined, args);
          assertThrow(me, specified, error);
        }
        catch (except) {
          assertThrow(me, specified, error, except);
        }
      }
      else if (isGeneratorFunction(value)) {
        return apply(go, undefined, union([value], args))
          .then(function () {
            assertThrow(me, specified, error);
          })
          .catch(function (except) {
            assertThrow(me, specified, error, except);
          });
      }
      else if (isAsyncFunction(value)) {
        return apply(value, undefined, args)
          .then(function () {
            assertThrow(me, specified, error);
          })
          .catch(function (except) {
            assertThrow(me, specified, error, except);
          });
      }
    }
  }
};

function newIs(me) {
  return {
    get undefined() { return assertValue(me, me.value === undefined, 'undefined') },
    get null() { return assertValue(me, me.value === null, 'null') },
    get void() { return assertValue(me, me.value === undefined || me.value === null, 'void') },
    get ok() { return assertValue(me, me.value, 'ok') },
    get NaN() { return assertValue(me, me.value !== me.value, 'NaN') },
    get finite() { return assertValue(me, Number.isFinite(me.value), 'finite') },
    get a() { return newA(me) },
    get an() { return newA(me) },
    equal: function (expect) { assertEqual(me, normalEqual, 'equal to', expect) },
    get strict() {
      return {
        equal: function (expect) { assertEqual(me, strictEqual, 'strict equal to', expect) }
      }
    },
    get deep() {
      return {
        equal: function (expect) { assertDeepEqual(me, normalEqual, 'deep equal to', expect) },
        get strict() {
          return {
            equal: function (expect) { assertDeepEqual(me, strictEqual, 'deep strict equal to', expect) }
          }
        }
      }
    },
  };
}

function newHas(me) {
  return {
    property: function (property) { assertHasProperty(me, property) },
    get own() {
      return {
        property: function (property) { assertHasOwnProperty(me, property) },
        get enumerable() {
          return {
            property: function (property) { assertHasOwnEnumerableProperty(me, property) }
          }
        }
      }
    },
    get enumerable() {
      return {
        property: function (property) { assertHasEnumerableProperty(me, property) }
      }
    }
  }
}

function newA(me) {
  return {
    get boolean() { assertType(me, 'boolean') },
    get number() { assertType(me, 'number') },
    get string() { assertType(me, 'string') },
    get symbol() { assertType(me, 'symbol') },
    get object() { assertType(me, 'object') },
    get function() { assertType(me, 'function') },
    get Object() { assertInstance(me, Object) },
    get Function() { assertInstance(me, Function) },
    get Boolean() { assertInstance(me, Boolean) },
    get Number() { assertInstance(me, Number) },
    get String() { assertInstance(me, String) },
    get Array() { assertInstance(me, Array) },
    get RegExp() { assertInstance(me, RegExp) },
    get Date() { assertInstance(me, Date) },
    get Error() { assertInstance(me, Error) },
    get Set() { assertInstance(me, Set) },
    get WeakSet() { assertInstance(me, WeakSet) },
    get Map() { assertInstance(me, Map) },
    get WeakMap() { assertInstance(me, WeakMap) },
    get Arguments() { assertTag(me, 'Arguments') },
    get Iterator() { assertInstanceOf(me, isIterator(me.value), 'Iterator') },
    get Promise() { assertInstance(me, Promise) },
    get Generator() { assertTag(me, 'Generator') },
    get GeneratorFunction() { assertTag(me, 'GeneratorFunction') },
    get AsyncFunction() { assertTag(me, 'AsyncFunction') },
    get instance() { return { of: function (type) { assertInstance(me, type) } } }
  };
}

function assertValue(it, assert, verb) {
  if (!assert ^ it.no)
    it.fail = disappoint(textify(it.value), 'is', it.no, verb);
  report(it);
}

function assertEqual(it, compare, verb, expect) {
  var value = it.value, not = it.no, assert;
  assert = compare(value, expect);
  if (!assert ^ not) {
    var type = typeclass(value);
    if (match(type, /^[A-Z]|symbol/) && type === typeclass(expect))
      verb += not ? ' the same' : ' another';
    it.fail = "hope " + textify(value) + ' is ' + (not ? 'not ' : '') + verb + ' ' + textify(expect) + '.';
  }
  report(it);
}

function assertDeepEqual(it, compare, verb, expect) {
  var value = it.value, not = it.no, assert, dif;
  dif = diff(value, expect, compare);
  if (!!dif ^ not)
    it.fail = "hope " + textify(value) + ' is ' + (not ? 'not ' : '') + verb + ' ' + textify(expect) + '.'
      + '\n' + (dif ? dif : 'there is no different for ' + verb + '.');
  report(it);
}



function assertType(it, type) {
  if ((genusof(it.value) !== type) ^ it.no)
    it.fail = disappoint(textify(it.value), 'is', it.no, 'type as', type);
  report(it);
}

function assertInstance(it, type) {
  if (isFunction(type)) {
    assertInstanceOf(it, isFunction(type) && it.value instanceof type, funcname(type));
  }
  else {
    it.fail = 'Error: ' + textify(type) + ' is not callable.';
    report(it);
  }
}

function assertTag(it, type) {
  assertInstanceOf(it, tagof(it.value) === type, type);
}

function assertInstanceOf(it, assert, type) {
  if (!assert ^ it.no)
    it.fail = disappoint(textify(it.value), 'is', it.no, 'an instance of', type);
  report(it);
}

function disappoint(one, vi, not, vt, other) {
  return 'Hope ' + one + ' ' + vi + (not ? ' not ' : ' ') + vt + (other ? ' ' + other : '') + '.';
}

function assertHasProperty(it, property) {
  if (assertObject(it)) {
    assertProperty(it, property in it.value, 'property', property);
  }
}

function assertHasOwnProperty(it, property) {
  if (assertObject(it)) {
    assertProperty(it, hasOwnProperty(it.value, property), 'own property', property);
  }
}

function assertHasEnumerableProperty(it, property) {
  if (assertObject(it)) {
    var desc = getPropertyDescriptor(it.value, property);
    assertProperty(it, desc && desc.enumerable, 'enumerable property', property);
  }
}

function assertHasOwnEnumerableProperty(it, property) {
  if (assertObject(it)) {
    var desc = getOwnPropertyDescriptor(it.value, property);
    assertProperty(it, desc && desc.enumerable, 'own enumerable property', property);
  }
}

function assertProperty(it, assert, verb, property) {
  var no = it.no;
  if (!assert ^ no)
    it.fail = 'But ' + textify(it.value) + ' has ' + (no ? '' : 'no ') + verb + ' ' + stringify(property) + '.';
  report(it);
}

function assertObject(it) {
  return isObject(it.value) || (it.fail = 'But ' + textify(it.value) + ' is not an object!', report(it));
}

function assertFunction(it) {
  return isFunction(it.value) || (it.fail = 'But ' + textify(it.value) + ' is not a function!', report(it))
}

function assertThrow(it, specified, error, except) {
  var not = it.no, ok = arguments.length < 4;

  if (ok) {
    if (!not)
      it.fail = fail(specified ? textify(error) : '', textify(except));
  }
  else if (specified) {
    if (isFunction(error)) {
      if (!(except instanceof error) ^ not)
        it.fail = fail(funcname(error) + ' object', textify(except));
    }
    else if (isString(error)) {
      error = stringify(error);
      if (isString(except)) {
        except = stringify(except);
      }
      else if (isObject(except)) {
        if (hasProperty(except, 'message')) {
          except = stringify(except.message);
        }
        else {
          except = textify(except);
        }
      }
      else {
        except = textify(except);
      }
      if ((error !== except) ^ not)
        it.fail = fail(error, except);
    }
    else if ((error !== except) ^ not) {
      it.fail = fail(textify(error), textify(except));
    }
  }
  else if (not) {
    it.fail = fail('', textify(except));
  }
  report(it);

  function fail(error, except) { return 'Hope' + (not ? ' not' : '') + ' throw ' + (error && error + ' ') + 'but throw ' + (ok ? 'nothing' : except) + '.' };
}

function typeclass(any) {
  var type = genusof(any), proto;
  if (type === 'object' || type === 'function') {
    if (proto = getPrototype(any)) {
      if (hasOwnProperty(proto, 'constructor')) {
        type = funcname(proto.constructor);
      }
      else {
        type = tagof(any);
      }
    }
    else {
      type = 'null prototype';
    }
  }
  return type;
}

function funcname(any) {
  return isFunction(any) ?
    any.name || '[anonymous]' : '';
}

function normalEqual(a, b) { return a == b || typeof a === "number" && typeof b === "number" && EPSILON >= a-b && a-b>=-EPSILON }

function strictEqual(a, b) { return a === b || typeof a === "number" && typeof b === "number" && EPSILON >= a-b && a-b>=-EPSILON }

function textify(any) {
  var s = typeclass(any);
  if (s === 'string' || s === 'boolean') {
    s += ' ' + stringify(any);
  }
  else if (s === 'number' || s === 'symbol') {
    s += ' ' + String(any);
  }
  else if (s === 'Date' || s === 'String' || s === 'Number' || s === 'Boolean') {
    s += ' ' + stringify(any.valueOf());
  }
  else if (s === 'null prototype') {
    s = 'object with ' + s;
  }
  else if (s !== 'undefined' && s !== 'null') {
    s += ' object';
  }
  return s;
}

function diff(a, b, equal) {
  var aValue, bValue;
  if (!equal(a, b)) {
    if (isObject(a) && isObject(b)) {
      if (isRegExp(a) && isRegExp(b)) {
        aValue = a.toString(), bValue = b.toString();
        if (!equal(aValue, bValue))
          return ': one is ' + aValue + ', the other is ' + bValue + '.';
      }
      var aKeys = Object.keys(a), bKeys = Object.keys(b);
      var i = aKeys.length, length = bKeys.length;
      if (i > length)
        length = i;
      aKeys.sort();
      bKeys.sort();
      var aKey, bKey;
      for (i = 0; i < length && (aKey = aKeys[i]) === (bKey = bKeys[i]); i++) {
        aValue = a[aKey], bValue = b[bKey];
        var dif = diff(aValue, bValue, equal);
        if (dif) {
          return propexp(aKey) + dif;
        }
      }
      if (aKey !== bKey) {
        if (aKey < bKey || bKey === undefined) {
          return propexp(aKey) + ': one is ' + textify(a[aKey]) + ', the other is absent.';
        }
        if (bKey < aKey || aKey === undefined) {
          return propexp(bKey) + ': one is absent, the other is ' + textify(b[bKey]) + '.';
        }
      }
    }
    else {
      return ': one is ' + textify(a) + ', the other is ' + textify(b);
    }
  }

  function propexp(prop) {
    if (match(prop, /[a-zA-Z_$][\w$]*/))
      return '.' + prop;
    if (match(prop, /^0$|^[1-9]\d*$/))
      return '[' + prop + ']';
    return '[' + stringify(prop) + ']';
  }
}


/** -----------------------------------------------------------------------------------------------
 * go.js
 */

function go(gen) {
  var self = this;
  var args = piece(arguments, 1);

  return new Promise(function (resolve, reject) {
    if (typeof gen === "function")
      gen = gen.apply(self, args);
    if (!gen || typeof gen.next !== "function")
      return resolve(gen);

    goon();

    function goon(value) {
      var state;
      try {
        state = gen.next(value);
      }
      catch (e) {
        return reject(e);
      }
      next(state);
    }

    function stop(err) {
      var state;
      try {
        state = gen.throw(err);
      }
      catch (e) {
        return reject(e);
      }
      next(state);
    }

    function next(state) {
      if (state.done)
        return resolve(state.value);
      var value = state.value;
      if (isPromise(value)) {
        value.then(goon, stop);
      }
      else {
        goon(value);
      }
    }
  })
}


/** -----------------------------------------------------------------------------------------------
 * run.js
 */

function Timeout(I) {
  this.I = I;
}

function checktime(me) {
  var I = me;
  while (I) {
    if (now() - I.zero >= I.timeout) {
      throw new Timeout(I);
    }
    I = I.parent;
  }
  return me;
}

async function run() {
  var me = this, func = me.func;
  var topic = me.topic;
  if (me.timeout)
    topic += format("(#t%dms)", me.ms);
  me.zero = now();
  try {
    if (isSyncFunction(func)) {
      if (func.name !== '$') {
        print(indent(topic, me.parent.indent));
        func(me);
      }
      else {
        await new Promise(function (goon) {
          var it = newIt(me.parent, topic);
          me.parent.do = function () {
            if (!it.end) {
              reporting();
              iProto.do.apply(me, arguments);
              goon();
            }
          }
          func(done);

          function done(err) {
            if (!it.end) {
              reporting(err);
              goon();
            }
          }
          function reporting(err) {
            if (err) {
              it.fail = err instanceof Error ? err.message : String(err);
            }
            report(it);
          }
        });
      }
    }
    else if (isGeneratorFunction(func)) {
      print(indent(topic, me.parent.indent));
      await go(func, me);
    }
    else if (isAsyncFunction(func)) {
      print(indent(topic, me.parent.indent));
      await func(me);
    }

    var us = me.us;
    for (var i = 0; i < us.length; i++)
      await us[i].run();
    summarize(me);
  }
  catch (err) {
    var s;
    if (err instanceof Timeout) {
      if (err.I !== me) throw err;  // 若不是本层任务超时，则抛出至上层处理。
      s = indent(format('#e⦸ Timeout Error: %dms!', err.I.timeout), err.I.indent);
    }
    else {
      s = format('#e⦸ %s: %s', err.name, err.message);
      var trace = getTrace(err);
      if (trace)
        s += "\n  " + trace;
      s = indent(s, me.indent);
    }
    print(s);
    me.end = 1;
  }
}

function summarize(me) {
  var s = sum(me);
  var total = s.total, okey = s.okey, fail = s.fail, miss = s.miss;
  s = format("#t✈#i Total asserts: #t%d#i,", total);
  if (okey) {
    s += format(' okey: #s%d%s#i,', okey, rate(okey));
  }
  if (fail) {
    s += format(' fail: #f%d%s#i,', fail, rate(fail));
  }
  if (miss) {
    s += format(' miss: #t%d%s#i,', miss, rate(miss));
  }

  s += format(" duration: #t%d#ims.", now() - me.zero);
  print(indent(s, me.indent));

  function rate(value) {
    return Number.isInteger(value = value / total * 100) ? '(' + value + '%)' : '';
  }
}

function sum(me) {
  var its = me.its, total = its.length, okey = 0, fail = 0, miss = 0;
  for (var i = 0; i < total; i++) {
    var it = its[i];
    if (it.end) {
      if (it.fail) {
        fail++;
      }
      else {
        okey++;
      }
    }
    else {
      miss++;
    }
  }
  its = me.us;
  for(var i=0; i<its.length; i++) {
    me = sum(its[i]);
    total += me.total;
    okey += me.okey;
    fail += me.fail;
    miss += me.miss;
  }
  return {total, okey, fail, miss};
}

function errors(me) {
  var errs = 0, its = me.its, us = me.us;
  for (var i = 0; i < its.length; i++) {
    var it = its[i];
    if (it.end) {
      if (it.fail)
        errs++;
    }
    else {
      errs++;
    }
  }
  for (var i = 0; i < us.length; i++)
    errs += errors(us[i]);
  return errs;
} 

/** -----------------------------------------------------------------------------------------------
 * i.js
 */

function newI(parent, topic, func, timeout) {
  var I = create(iProto);
  I.parent = parent;
  I.topic = topic;
  I.func = func;
  I.timeout = timeout;
  I.us = [];
  I.its = [];
  if (parent) {
    I.indent = parent.indent + "  ";
    I.path = parent.path;
  }
  else {
    I.indent = "";
  }
  return I;
}

const iProto = {
  do: function (topic, func, timeout) {
    push(this.us, newI(this, topic, func, timeout));
  },

  log: function (s) {
    var me = checktime(this);
    s = apply(format, undefined, arguments);
    print(indent(s, me.indent));
  },

  delay: async function (ms) {
    var me = checktime(this);
    var I = me;
    while (I) {
      var left = I.timeout + I.zero - now();
      if (left < ms)
        ms = left;
      I = I.parent;
    }
    if (ms >= 0)
      await new Promise(function (resolve) {
        setTimeout(resolve, ms);
      });
  },
  assert: assert,
  get am() {
    var me = this;
    return { sure: bind(assert, me) };
  },
  hope: hope,
  say: say,
  run: run
};

function say(topic) {
  var me = this;
  var it = newIt(me, topic);
  return {
    if: function (assert) {
      if (!assert)
        it.fail = 'Assert failure!';
      report(it);
    },
    as: function (value) {
      it.value = value;
      return it;
    },
    on: function on(func) {
      try {
        func();
      }
      catch (err) {
        it.fail = 'Throw ' + String(err);
      }
      report(it);
    }
  };
}


/** -----------------------------------------------------------------------------------------------
 * load.js
 */

(function () {
  iProto.get = function (url) {
    url = purl(url, this.path);
    return get(url);
  };

  var jsed = {};
  iProto.js = function (url) {
    url = purl(url, this.path);
    if (!jsed[url]) {
      jsed[url] = 1;
      var code = get(url) + '\n//# sourceURL=' + url;
      var path = this.path;
      this.path = url;
      try {
        global.eval(code);
      }
      finally {
        this.path = path;
      }
    }
  }

  /** purl(url, rel)  计算相对路径并规格化 */
  var reUrl = /^(https?:\/\/[\w-.]+(?::\d+)?|)([\w\/.-]+)(.*|)/;
  var reRel = /^(https?:\/\/[\w-.]+(?::\d+)?|)(\/(?:[\w.-]+\/)*)/;

  function purl(url, rel) {
    var ms = match(url, reUrl);
    if (ms && !ms[1] && (rel = match(rel, reRel))) {
      url = ms[2];
      if (url[0] !== '/') {
        url = rel[2] + url;
      }
      url = rel[1] + furl(url) + ms[3];
    }
    return url;
  }

  /** furl(url) 路径规格化 */
  var reSlash = /\/+/;

  function furl(src) {
    var des = [];
    src = split(src, reSlash);
    for (var i = 0, l = src.length; i < l; i++) {
      var sym = src[i];
      if (des.length) {
        if (sym !== '.') {
          var end = des[des.length - 1];
          if (sym !== '..') {
            if (end === '.' && sym) pop(des);
            push(des, sym);
          }
          else if (end === '..') {
            push(des, sym);
          }
          else if (end) {
            pop(des);
          }
        }
      }
      else {
        push(des, sym);
      }
    }
    return des.join('/');
  }
})();




/** -----------------------------------------------------------------------------------------------
 * main.js
 */

async function main() {
  try {
    await I.run();
    exit(errors(I));
  }
  catch (e) {
    log("#eUncaught %s: %s", e.name, e.message);
    exit(-1);
  }
}

function exit(code) {
  if (this.window) {
    remote("exit", code);
    this.window.close();
  }
  else {
    process.exit(code);
  }
}


var debug = "";


/** -------------------------------------------------------------------------------------------------------------------
 * server.js
 */

//const ITJS = "/** -------------------------------------------------------------------------------------------------------------------\n * it.js\n */\n\n(function (global, window, Function, Object, String, Array, RegExp, Date, Error, Promise) {\n  global = this; window = global.window;\n  const currentScript = document.currentScript;\n  const cases = currentScript.getAttribute(\"tests\");\n  const debug = currentScript.hasAttribute(\"debug\");\n  if(!debug) document.head.removeChild(currentScript);\n\n  //const BROWSER = 1\n  /** -----------------------------------------------------------------------------------------------\n   * lib.js\n   */\n  \n  var undefined;\n  \n  /** --------------------------------------------------------------------------\n   * Function\n   */\n  var nop = Function.prototype;\n  var _call = nop.call;\n  var _apply = nop.apply;\n  var _bind = nop.bind;\n  var func = _call.bind(_bind, _call);\n  var bind = func(_bind);\n  var call = func(_call);\n  var apply = func(_apply);\n  \n  function isFunction(any) {\n    return typeof any === 'function';\n  }\n  \n    /** --------------------------------------------------------------------------\n     * Object\n     */\n    var Object_prototype = Object.prototype;\n    var create = Object.create;\n    var getPrototype = Object.getPrototypeOf;\n    var setPrototype = Object.setPrototypeOf;\n    var _isPrototypeOf = Object_prototype.isPrototypeOf;\n  \n    function isObject(any) {\n      return Object(any) === any;    // typeof any === 'object' && any !== nil;\n    }\n  \n    function genusof(any) {\n      return any === null ? \"null\" : typeof any;\n    }\n  \n    var reTrimTag = /\\[object |\\]/g;\n    function tagof(any) {\n      return replace(call(Object_prototype.toString, any), reTrimTag, '');\n    }\n  \n    var hasOwnProperty = func(Object_prototype.hasOwnProperty);\n    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n  \n    function hasProperty(obj, prop) {\n      while (obj) {\n        if (hasOwnProperty(obj, prop))\n          return obj;\n        obj = getPrototype(obj);\n      }\n    }\n  \n    function getPropertyDescriptor(obj, prop) {\n      var desc;\n      while (obj) {\n        if (desc = getOwnPropertyDescriptor(obj, prop))\n          return desc;\n        obj = getPrototype(obj);\n      }\n    }\n  \n    /** --------------------------------------------------------------------------\n     * String\n     */\n    var String_prototype = String.prototype;\n  \n    function isString(any) {\n      return typeof any === 'string';\n    }\n  \n    var trim = func(String_prototype.trim);\n    var replace = func(String_prototype.replace);\n    var match = func(String_prototype.match);\n    var split = func(String_prototype.split);\n    var stringify = JSON.stringify;\n  \n    /** --------------------------------------------------------------------------\n     * Array\n     */\n    var Array_prototype = Array.prototype;\n    var piece = func(Array_prototype.slice);\n    var splice = func(Array_prototype.splice);\n    var push = func(Array_prototype.push);\n    var pop = func(Array_prototype.pop);\n  \n    /** --------------------------------------------------------------------------\n     * RegExp\n     */\n    function isRegExp(any) {\n      return any instanceof RegExp;\n    }\n  \n    /** --------------------------------------------------------------------------\n     * Date\n     */\n    var now = Date.now;\n  \n    /** --------------------------------------------------------------------------\n     * Iterator, Promise, Generator, Async Function\n     */\n    var isIterator = bind(_isPrototypeOf, getPrototype(getPrototype(''[Symbol.iterator]())));\n    var isPromise = bind(_isPrototypeOf, Promise.prototype);\n  \n    function isGeneratorFunction(any) {\n      return tagof(any) === 'GeneratorFunction';\n    }\n  \n    function isAsyncFunction(any) {\n      return tagof(any) === 'AsyncFunction';\n    }\n  \n    function isSyncFunction(any) {\n      return tagof(any) === 'Function';\n    }\n  \n    /** indent(code, spaces) 缩进代码行 */\n    function indent(code, spaces) {\n      return code.replace(/^/gm, spaces);\n    }\n  \n  \n  /** -----------------------------------------------------------------------------------------------\n   * log.js\n   */\n  \n  function report(it) {\n    if (!(it.end = it.parent.end)) {\n      var s = it.topic;\n      if (it.ms) {\n        s += format(\" (timeout #m%dms)\", it.ms);\n      }\n      if (it.fail) {\n        s = format(\"#f✘ %s\\n#e%s%s\", s, indent(it.fail, \"  \"), it.trace ? \"\\n\" + indent(it.trace, \"  #m\") : \"\");\n      }\n      else {\n        s = format(\"#s✔ %s\", s);\n      }\n      log(\"%s\", indent(s, it.indent));\n      it.end = 1;\n    }\n  }\n  \n  function review() {\n    var me = this, it = me.its[me.its.length - 1];\n    if (it && !it.func && !it.end) {\n      var s = '#t• ' + it.topic;\n      if (it.trace)\n        s += indent('\\n#e' + it.trace, '  ');\n      log(indent(s, it.indent));\n    }\n  }\n  \n  function log() {\n    print(format.apply(undefined, arguments));\n  }\n  \n  const server = cases\n    ? Server()\n    : nop;\n  function print(s) {\n    server(\"log\", textcolor(s))\n    console.log.apply(console, argscolor(arguments));\n  }\n  \n  const textcolors = {\n    0: \"\\x1b[0m\",\n    i: \"\\u001b[0m\\u001b[37m\",\n    s: \"\\u001b[1m\\u001b[32m\",\n    f: \"\\u001b[1m\\u001b[31m\",\n    e: \"\\u001b[0m\\u001b[31m\",\n    t: \"\\u001b[1m\\u001b[34m\",\n    m: \"\\u001b[1m\\u001b[30m\"\n  };\n  \n  function textcolor(text) {\n    return replace(text, /#[sftiem]/g, (s) => textcolors[s[1]] || textcolors[0]) + textcolors[0];\n  }\n  \n  const argscolors = {\n    0: \"\",\n    i: \"color:lightgray\",\n    s: \"color:lawngreen;font-weight:900\",\n    f: \"color:tomato;font-weight:900\",\n    e: \"color:red\",\n    t: \"color:royalblue;font-weight:900\",\n    m: \"color:darkgrey\"\n  };\n  \n  function argscolor(args) {\n    var i = 1;\n    args[0] = replace(args[0], /#\\w/g, (s) => (args[i++] = argscolors[s[1]] || \"\", \"%c\"));\n    args.length = i;\n    return args;\n  }\n  \n  function format(s) {\n    var i = 1, args = arguments;\n    return replace(s, /%[sd]/g, function (s) {\n      return i < args.length ? args[i++] : s;\n    });\n  }\n  \n  /** -----------------------------------------------------------------------------------------------\n   * trace.js\n   */\n  \n  /** get(path) 获取文本资源 */\n  var get;\n  \n  if (this.window) {\n    get = function (path) {\n      var http = new XMLHttpRequest;\n      http.open('GET', path, false);\n      http.send();\n      return http.status / 100 ^ 2 ? '' : http.responseText;\n    };\n  }\n  else {\n    const fs = require('fs');\n    get = function (path) {\n      return fs.readFileSync(path, { encoding: 'utf-8' });\n    };\n  }\n  \n  var reWhere = RegExp('\\\\b' + where.name + '\\\\b');\n  var reHere = /((?:https?:\\/\\/[\\w.-]+(?::\\d+)?|)[\\w./@-]+(?:\\?.*|)):(\\d+):(\\d+)/;\n  function where(deep) {\n    var stack = split(Error().stack, \"\\n\");\n    for (var i = 0, line; line = stack[i++];) {\n      if (match(line, reWhere)) break;\n    }\n    if (i < stack.length) {\n      var ms = match(stack[i + deep], reHere);\n      if (ms)\n        return {\n          trace: ms[0],\n          loc: ms[1],\n          row: ms[2] - 1,\n          col: ms[3] - 1\n        };\n    }\n  }\n  \n  var reTrace = /((?:https?:\\/\\/[\\w.-]+(?::\\d+)?|)[\\w./@-]+(?:\\?.*|)):(\\d+):(\\d+)/;\n  function getTrace(error) {\n    var stack = error.stack;\n    if (stack) {\n      stack = split(stack, \"\\n\");\n      for (var i = 0, item; item = stack[i++];) {\n        var ms = match(item, reTrace);\n        if (ms) return ms[0];\n      }\n    }\n  }\n  \n  function getLine(deep) {\n    var here, rows, row;\n    deep += 1;\n    if (here = where(deep)) {\n      if (rows = getRows(here.loc)) {\n        if (row = rows[here.row]) {\n          return { code: row, trace: here.trace }\n        }\n      }\n    }\n  }\n  \n  var cachedRows = {};\n  function getRows(loc) {\n    var rows;\n    if (hasOwnProperty(cachedRows, loc)) {\n      rows = cachedRows[loc];\n    }\n    else {\n      rows = cachedRows[loc] = split(get(loc), \"\\n\");\n    }\n    return rows;\n  }\n  \n  \n  \n  /** -----------------------------------------------------------------------------------------------\n   * assert.js\n   */\n  const EPSILON = 0.0000001192092896;\n  \n  function assert(assert) {\n    var it = newIt(this);\n    if (!assert)\n      it.fail = 'Assert failure!';\n    report(it);\n  }\n  \n  function hope(value) {\n    var it = newIt(this, \"\", value);\n    if (arguments.length > 1)\n      it.args = piece(arguments, 1);\n    return it;\n  }\n  \n  function newIt(parent, topic, value) {\n    call(review, parent);\n    var it = create(itProto);\n    it.parent = parent;\n    var line = getLine(2), code;\n    if (line) {\n      code = trim(line.code);\n      it.trace = line.trace;\n    }\n    it.topic = topic || code || \"unknown testing\"\n    it.value = value;\n    it.indent = parent.indent;\n    it.zero = now();\n    push(parent.its, it);\n    return it;\n  }\n  \n  var itProto = {\n    get be() { return this },\n    get is() {\n      var me = this;\n      var is = setPrototype(newIs(me), newA(me));\n      return setPrototype({ get not() { me.no = 1; return is } }, is);\n    },\n    get not() {\n      this.no = !this.no;\n      return this;\n    },\n  \n    equal: function (expect) { assertEqual(this, normalEqual, 'equals', expect) },\n  \n    get strict() {\n      var me = this;\n      return {\n        equal: function (expect) { assertEqual(me, strictEqual, 'strict equals', expect) }\n      }\n    },\n  \n    get deep() {\n      var me = this;\n      return {\n        equal: function (expect) { assertDeepEqual(me, normalEqual, 'deep equals', expect) },\n        get strict() {\n          return {\n            equal: function (expect) { assertDeepEqual(me, strictEqual, 'deep strict equals', expect) }\n          }\n        }\n      }\n    },\n  \n    get a() { return newA(this) },\n  \n    get has() {\n      var me = this;\n      var has = newHas(me);\n      return setPrototype({ get not() { me.no = 1; return has }, get no() { me.no = 1; return has } }, has);\n    },\n    throw: function () {\n      var me = this, value = me.value, args = arguments, specified, error;\n      if (specified = args.length) error = args[0];\n      args = me.args;\n      if (assertFunction(me)) {\n        if (isSyncFunction(value)) {\n          try {\n            apply(value, undefined, args);\n            assertThrow(me, specified, error);\n          }\n          catch (except) {\n            assertThrow(me, specified, error, except);\n          }\n        }\n        else if (isGeneratorFunction(value)) {\n          return apply(go, undefined, union([value], args))\n            .then(function () {\n              assertThrow(me, specified, error);\n            })\n            .catch(function (except) {\n              assertThrow(me, specified, error, except);\n            });\n        }\n        else if (isAsyncFunction(value)) {\n          return apply(value, undefined, args)\n            .then(function () {\n              assertThrow(me, specified, error);\n            })\n            .catch(function (except) {\n              assertThrow(me, specified, error, except);\n            });\n        }\n      }\n    }\n  };\n  \n  function newIs(me) {\n    return {\n      get undefined() { return assertValue(me, me.value === undefined, 'undefined') },\n      get null() { return assertValue(me, me.value === null, 'null') },\n      get void() { return assertValue(me, me.value === undefined || me.value === null, 'void') },\n      get ok() { return assertValue(me, me.value, 'ok') },\n      get NaN() { return assertValue(me, me.value !== me.value, 'NaN') },\n      get finite() { return assertValue(me, Number.isFinite(me.value), 'finite') },\n      get a() { return newA(me) },\n      get an() { return newA(me) },\n      equal: function (expect) { assertEqual(me, normalEqual, 'equal to', expect) },\n      get strict() {\n        return {\n          equal: function (expect) { assertEqual(me, strictEqual, 'strict equal to', expect) }\n        }\n      },\n      get deep() {\n        return {\n          equal: function (expect) { assertDeepEqual(me, normalEqual, 'deep equal to', expect) },\n          get strict() {\n            return {\n              equal: function (expect) { assertDeepEqual(me, strictEqual, 'deep strict equal to', expect) }\n            }\n          }\n        }\n      },\n    };\n  }\n  \n  function newHas(me) {\n    return {\n      property: function (property) { assertHasProperty(me, property) },\n      get own() {\n        return {\n          property: function (property) { assertHasOwnProperty(me, property) },\n          get enumerable() {\n            return {\n              property: function (property) { assertHasOwnEnumerableProperty(me, property) }\n            }\n          }\n        }\n      },\n      get enumerable() {\n        return {\n          property: function (property) { assertHasEnumerableProperty(me, property) }\n        }\n      }\n    }\n  }\n  \n  function newA(me) {\n    return {\n      get boolean() { assertType(me, 'boolean') },\n      get number() { assertType(me, 'number') },\n      get string() { assertType(me, 'string') },\n      get symbol() { assertType(me, 'symbol') },\n      get object() { assertType(me, 'object') },\n      get function() { assertType(me, 'function') },\n      get Object() { assertInstance(me, Object) },\n      get Function() { assertInstance(me, Function) },\n      get Boolean() { assertInstance(me, Boolean) },\n      get Number() { assertInstance(me, Number) },\n      get String() { assertInstance(me, String) },\n      get Array() { assertInstance(me, Array) },\n      get RegExp() { assertInstance(me, RegExp) },\n      get Date() { assertInstance(me, Date) },\n      get Error() { assertInstance(me, Error) },\n      get Set() { assertInstance(me, Set) },\n      get WeakSet() { assertInstance(me, WeakSet) },\n      get Map() { assertInstance(me, Map) },\n      get WeakMap() { assertInstance(me, WeakMap) },\n      get Arguments() { assertTag(me, 'Arguments') },\n      get Iterator() { assertInstanceOf(me, isIterator(me.value), 'Iterator') },\n      get Promise() { assertInstance(me, Promise) },\n      get Generator() { assertTag(me, 'Generator') },\n      get GeneratorFunction() { assertTag(me, 'GeneratorFunction') },\n      get AsyncFunction() { assertTag(me, 'AsyncFunction') },\n      get instance() { return { of: function (type) { assertInstance(me, type) } } }\n    };\n  }\n  \n  function assertValue(it, assert, verb) {\n    if (!assert ^ it.no)\n      it.fail = disappoint(textify(it.value), 'is', it.no, verb);\n    report(it);\n  }\n  \n  function assertEqual(it, compare, verb, expect) {\n    var value = it.value, not = it.no, assert;\n    assert = compare(value, expect);\n    if (!assert ^ not) {\n      var type = typeclass(value);\n      if (match(type, /^[A-Z]|symbol/) && type === typeclass(expect))\n        verb += not ? ' the same' : ' another';\n      it.fail = \"hope \" + textify(value) + ' is ' + (not ? 'not ' : '') + verb + ' ' + textify(expect) + '.';\n    }\n    report(it);\n  }\n  \n  function assertDeepEqual(it, compare, verb, expect) {\n    var value = it.value, not = it.no, assert, dif;\n    dif = diff(value, expect, compare);\n    if (!!dif ^ not)\n      it.fail = \"hope \" + textify(value) + ' is ' + (not ? 'not ' : '') + verb + ' ' + textify(expect) + '.'\n        + '\\n' + (dif ? dif : 'there is no different for ' + verb + '.');\n    report(it);\n  }\n  \n  \n  \n  function assertType(it, type) {\n    if ((genusof(it.value) !== type) ^ it.no)\n      it.fail = disappoint(textify(it.value), 'is', it.no, 'type as', type);\n    report(it);\n  }\n  \n  function assertInstance(it, type) {\n    if (isFunction(type)) {\n      assertInstanceOf(it, isFunction(type) && it.value instanceof type, funcname(type));\n    }\n    else {\n      it.fail = 'Error: ' + textify(type) + ' is not callable.';\n      report(it);\n    }\n  }\n  \n  function assertTag(it, type) {\n    assertInstanceOf(it, tagof(it.value) === type, type);\n  }\n  \n  function assertInstanceOf(it, assert, type) {\n    if (!assert ^ it.no)\n      it.fail = disappoint(textify(it.value), 'is', it.no, 'an instance of', type);\n    report(it);\n  }\n  \n  function disappoint(one, vi, not, vt, other) {\n    return 'Hope ' + one + ' ' + vi + (not ? ' not ' : ' ') + vt + (other ? ' ' + other : '') + '.';\n  }\n  \n  function assertHasProperty(it, property) {\n    if (assertObject(it)) {\n      assertProperty(it, property in it.value, 'property', property);\n    }\n  }\n  \n  function assertHasOwnProperty(it, property) {\n    if (assertObject(it)) {\n      assertProperty(it, hasOwnProperty(it.value, property), 'own property', property);\n    }\n  }\n  \n  function assertHasEnumerableProperty(it, property) {\n    if (assertObject(it)) {\n      var desc = getPropertyDescriptor(it.value, property);\n      assertProperty(it, desc && desc.enumerable, 'enumerable property', property);\n    }\n  }\n  \n  function assertHasOwnEnumerableProperty(it, property) {\n    if (assertObject(it)) {\n      var desc = getOwnPropertyDescriptor(it.value, property);\n      assertProperty(it, desc && desc.enumerable, 'own enumerable property', property);\n    }\n  }\n  \n  function assertProperty(it, assert, verb, property) {\n    var no = it.no;\n    if (!assert ^ no)\n      it.fail = 'But ' + textify(it.value) + ' has ' + (no ? '' : 'no ') + verb + ' ' + stringify(property) + '.';\n    report(it);\n  }\n  \n  function assertObject(it) {\n    return isObject(it.value) || (it.fail = 'But ' + textify(it.value) + ' is not an object!', report(it));\n  }\n  \n  function assertFunction(it) {\n    return isFunction(it.value) || (it.fail = 'But ' + textify(it.value) + ' is not a function!', report(it))\n  }\n  \n  function assertThrow(it, specified, error, except) {\n    var not = it.no, ok = arguments.length < 4;\n  \n    if (ok) {\n      if (!not)\n        it.fail = fail(specified ? textify(error) : '', textify(except));\n    }\n    else if (specified) {\n      if (isFunction(error)) {\n        if (!(except instanceof error) ^ not)\n          it.fail = fail(funcname(error) + ' object', textify(except));\n      }\n      else if (isString(error)) {\n        error = stringify(error);\n        if (isString(except)) {\n          except = stringify(except);\n        }\n        else if (isObject(except)) {\n          if (hasProperty(except, 'message')) {\n            except = stringify(except.message);\n          }\n          else {\n            except = textify(except);\n          }\n        }\n        else {\n          except = textify(except);\n        }\n        if ((error !== except) ^ not)\n          it.fail = fail(error, except);\n      }\n      else if ((error !== except) ^ not) {\n        it.fail = fail(textify(error), textify(except));\n      }\n    }\n    else if (not) {\n      it.fail = fail('', textify(except));\n    }\n    report(it);\n  \n    function fail(error, except) { return 'Hope' + (not ? ' not' : '') + ' throw ' + (error && error + ' ') + 'but throw ' + (ok ? 'nothing' : except) + '.' };\n  }\n  \n  function typeclass(any) {\n    var type = genusof(any), proto;\n    if (type === 'object' || type === 'function') {\n      if (proto = getPrototype(any)) {\n        if (hasOwnProperty(proto, 'constructor')) {\n          type = funcname(proto.constructor);\n        }\n        else {\n          type = tagof(any);\n        }\n      }\n      else {\n        type = 'null prototype';\n      }\n    }\n    return type;\n  }\n  \n  function funcname(any) {\n    return isFunction(any) ?\n      any.name || '[anonymous]' : '';\n  }\n  \n  function normalEqual(a, b) { return a == b || typeof a === \"number\" && typeof b === \"number\" && EPSILON >= a-b && a-b>=-EPSILON }\n  \n  function strictEqual(a, b) { return a === b || typeof a === \"number\" && typeof b === \"number\" && EPSILON >= a-b && a-b>=-EPSILON }\n  \n  function textify(any) {\n    var s = typeclass(any);\n    if (s === 'string' || s === 'boolean') {\n      s += ' ' + stringify(any);\n    }\n    else if (s === 'number' || s === 'symbol') {\n      s += ' ' + String(any);\n    }\n    else if (s === 'Date' || s === 'String' || s === 'Number' || s === 'Boolean') {\n      s += ' ' + stringify(any.valueOf());\n    }\n    else if (s === 'null prototype') {\n      s = 'object with ' + s;\n    }\n    else if (s !== 'undefined' && s !== 'null') {\n      s += ' object';\n    }\n    return s;\n  }\n  \n  function diff(a, b, equal) {\n    var aValue, bValue;\n    if (!equal(a, b)) {\n      if (isObject(a) && isObject(b)) {\n        if (isRegExp(a) && isRegExp(b)) {\n          aValue = a.toString(), bValue = b.toString();\n          if (!equal(aValue, bValue))\n            return ': one is ' + aValue + ', the other is ' + bValue + '.';\n        }\n        var aKeys = Object.keys(a), bKeys = Object.keys(b);\n        var i = aKeys.length, length = bKeys.length;\n        if (i > length)\n          length = i;\n        aKeys.sort();\n        bKeys.sort();\n        var aKey, bKey;\n        for (i = 0; i < length && (aKey = aKeys[i]) === (bKey = bKeys[i]); i++) {\n          aValue = a[aKey], bValue = b[bKey];\n          var dif = diff(aValue, bValue, equal);\n          if (dif) {\n            return propexp(aKey) + dif;\n          }\n        }\n        if (aKey !== bKey) {\n          if (aKey < bKey || bKey === undefined) {\n            return propexp(aKey) + ': one is ' + textify(a[aKey]) + ', the other is absent.';\n          }\n          if (bKey < aKey || aKey === undefined) {\n            return propexp(bKey) + ': one is absent, the other is ' + textify(b[bKey]) + '.';\n          }\n        }\n      }\n      else {\n        return ': one is ' + textify(a) + ', the other is ' + textify(b);\n      }\n    }\n  \n    function propexp(prop) {\n      if (match(prop, /[a-zA-Z_$][\\w$]*/))\n        return '.' + prop;\n      if (match(prop, /^0$|^[1-9]\\d*$/))\n        return '[' + prop + ']';\n      return '[' + stringify(prop) + ']';\n    }\n  }\n  \n  \n  /** -----------------------------------------------------------------------------------------------\n   * go.js\n   */\n  \n  function go(gen) {\n    var self = this;\n    var args = piece(arguments, 1);\n  \n    return new Promise(function (resolve, reject) {\n      if (typeof gen === \"function\")\n        gen = gen.apply(self, args);\n      if (!gen || typeof gen.next !== \"function\")\n        return resolve(gen);\n  \n      goon();\n  \n      function goon(value) {\n        var state;\n        try {\n          state = gen.next(value);\n        }\n        catch (e) {\n          return reject(e);\n        }\n        next(state);\n      }\n  \n      function stop(err) {\n        var state;\n        try {\n          state = gen.throw(err);\n        }\n        catch (e) {\n          return reject(e);\n        }\n        next(state);\n      }\n  \n      function next(state) {\n        if (state.done)\n          return resolve(state.value);\n        var value = state.value;\n        if (isPromise(value)) {\n          value.then(goon, stop);\n        }\n        else {\n          goon(value);\n        }\n      }\n    })\n  }\n  \n  \n  /** -----------------------------------------------------------------------------------------------\n   * run.js\n   */\n  \n  function Timeout(I) {\n    this.I = I;\n  }\n  \n  function checktime(me) {\n    var I = me;\n    while (I) {\n      if (now() - I.zero >= I.timeout) {\n        throw new Timeout(I);\n      }\n      I = I.parent;\n    }\n    return me;\n  }\n  \n  async function run() {\n    var me = this, func = me.func;\n    var topic = me.topic;\n    if (me.timeout)\n      topic += format(\"(#t%dms)\", me.ms);\n    me.zero = now();\n    try {\n      if (isSyncFunction(func)) {\n        if (func.name !== '$') {\n          print(indent(topic, me.parent.indent));\n          func(me);\n        }\n        else {\n          await new Promise(function (goon) {\n            var it = newIt(me.parent, topic);\n            me.parent.do = function () {\n              if (!it.end) {\n                reporting();\n                iProto.do.apply(me, arguments);\n                goon();\n              }\n            }\n            func(done);\n  \n            function done(err) {\n              if (!it.end) {\n                reporting(err);\n                goon();\n              }\n            }\n            function reporting(err) {\n              if (err) {\n                it.fail = err instanceof Error ? err.message : String(err);\n              }\n              report(it);\n            }\n          });\n        }\n      }\n      else if (isGeneratorFunction(func)) {\n        print(indent(topic, me.parent.indent));\n        await go(func, me);\n      }\n      else if (isAsyncFunction(func)) {\n        print(indent(topic, me.parent.indent));\n        await func(me);\n      }\n  \n      var us = me.us;\n      for (var i = 0; i < us.length; i++)\n        await us[i].run();\n      summarize(me);\n    }\n    catch (err) {\n      var s;\n      if (err instanceof Timeout) {\n        if (err.I !== me) throw err;  // 若不是本层任务超时，则抛出至上层处理。\n        s = indent(format('#e⦸ Timeout Error: %dms!', err.I.timeout), err.I.indent);\n      }\n      else {\n        s = format('#e⦸ %s: %s', err.name, err.message);\n        var trace = getTrace(err);\n        if (trace)\n          s += \"\\n  \" + trace;\n        s = indent(s, me.indent);\n      }\n      print(s);\n      me.end = 1;\n    }\n  }\n  \n  function summarize(me) {\n    var s = sum(me);\n    var total = s.total, okey = s.okey, fail = s.fail, miss = s.miss;\n    s = format(\"#t✈#i Total asserts: #t%d#i,\", total);\n    if (okey) {\n      s += format(' okey: #s%d%s#i,', okey, rate(okey));\n    }\n    if (fail) {\n      s += format(' fail: #f%d%s#i,', fail, rate(fail));\n    }\n    if (miss) {\n      s += format(' miss: #t%d%s#i,', miss, rate(miss));\n    }\n  \n    s += format(\" duration: #t%d#ims.\", now() - me.zero);\n    print(indent(s, me.indent));\n  \n    function rate(value) {\n      return Number.isInteger(value = value / total * 100) ? '(' + value + '%)' : '';\n    }\n  }\n  \n  function sum(me) {\n    var its = me.its, total = its.length, okey = 0, fail = 0, miss = 0;\n    for (var i = 0; i < total; i++) {\n      var it = its[i];\n      if (it.end) {\n        if (it.fail) {\n          fail++;\n        }\n        else {\n          okey++;\n        }\n      }\n      else {\n        miss++;\n      }\n    }\n    its = me.us;\n    for(var i=0; i<its.length; i++) {\n      me = sum(its[i]);\n      total += me.total;\n      okey += me.okey;\n      fail += me.fail;\n      miss += me.miss;\n    }\n    return {total, okey, fail, miss};\n  }\n  \n  function errors(me) {\n    var errs = 0, its = me.its, us = me.us;\n    for (var i = 0; i < its.length; i++) {\n      var it = its[i];\n      if (it.end) {\n        if (it.fail)\n          errs++;\n      }\n      else {\n        errs++;\n      }\n    }\n    for (var i = 0; i < us.length; i++)\n      errs += errors(us[i]);\n    return errs;\n  } \n  \n  /** -----------------------------------------------------------------------------------------------\n   * i.js\n   */\n  \n  function newI(parent, topic, func, timeout) {\n    var I = create(iProto);\n    I.parent = parent;\n    I.topic = topic;\n    I.func = func;\n    I.timeout = timeout;\n    I.us = [];\n    I.its = [];\n    if (parent) {\n      I.indent = parent.indent + \"  \";\n      I.path = parent.path;\n    }\n    else {\n      I.indent = \"\";\n    }\n    return I;\n  }\n  \n  const iProto = {\n    do: function (topic, func, timeout) {\n      push(this.us, newI(this, topic, func, timeout));\n    },\n  \n    log: function (s) {\n      var me = checktime(this);\n      s = apply(format, undefined, arguments);\n      print(indent(s, me.indent));\n    },\n  \n    delay: async function (ms) {\n      var me = checktime(this);\n      var I = me;\n      while (I) {\n        var left = I.timeout + I.zero - now();\n        if (left < ms)\n          ms = left;\n        I = I.parent;\n      }\n      if (ms >= 0)\n        await new Promise(function (resolve) {\n          setTimeout(resolve, ms);\n        });\n    },\n    assert: assert,\n    get am() {\n      var me = this;\n      return { sure: bind(assert, me) };\n    },\n    hope: hope,\n    say: say,\n    run: run\n  };\n  \n  function say(topic) {\n    var me = this;\n    var it = newIt(me, topic);\n    return {\n      if: function (assert) {\n        if (!assert)\n          it.fail = 'Assert failure!';\n        report(it);\n      },\n      as: function (value) {\n        it.value = value;\n        return it;\n      },\n      on: function on(func) {\n        try {\n          func();\n        }\n        catch (err) {\n          it.fail = 'Throw ' + String(err);\n        }\n        report(it);\n      }\n    };\n  }\n  \n  \n  /** -----------------------------------------------------------------------------------------------\n   * load.js\n   */\n  \n  (function () {\n    iProto.get = function (url) {\n      url = purl(url, this.path);\n      return get(url);\n    };\n  \n    var jsed = {};\n    iProto.js = function (url) {\n      url = purl(url, this.path);\n      if (!jsed[url]) {\n        jsed[url] = 1;\n        var code = get(url) + '\\n//# sourceURL=' + url;\n        var path = this.path;\n        this.path = url;\n        try {\n          global.eval(code);\n        }\n        finally {\n          this.path = path;\n        }\n      }\n    }\n  \n    /** purl(url, rel)  计算相对路径并规格化 */\n    var reUrl = /^(https?:\\/\\/[\\w-.]+(?::\\d+)?|)([\\w\\/.-]+)(.*|)/;\n    var reRel = /^(https?:\\/\\/[\\w-.]+(?::\\d+)?|)(\\/(?:[\\w.-]+\\/)*)/;\n  \n    function purl(url, rel) {\n      var ms = match(url, reUrl);\n      if (ms && !ms[1] && (rel = match(rel, reRel))) {\n        url = ms[2];\n        if (url[0] !== '/') {\n          url = rel[2] + url;\n        }\n        url = rel[1] + furl(url) + ms[3];\n      }\n      return url;\n    }\n  \n    /** furl(url) 路径规格化 */\n    var reSlash = /\\/+/;\n  \n    function furl(src) {\n      var des = [];\n      src = split(src, reSlash);\n      for (var i = 0, l = src.length; i < l; i++) {\n        var sym = src[i];\n        if (des.length) {\n          if (sym !== '.') {\n            var end = des[des.length - 1];\n            if (sym !== '..') {\n              if (end === '.' && sym) pop(des);\n              push(des, sym);\n            }\n            else if (end === '..') {\n              push(des, sym);\n            }\n            else if (end) {\n              pop(des);\n            }\n          }\n        }\n        else {\n          push(des, sym);\n        }\n      }\n      return des.join('/');\n    }\n  })();\n  \n  \n  \n  \n  /** -----------------------------------------------------------------------------------------------\n   * main.js\n   */\n  \n  async function main() {\n    try {\n      await I.run();\n      exit(errors(I));\n    }\n    catch (e) {\n      log(\"#eUncaught %s: %s\", e.name, e.message);\n      exit(-1);\n    }\n  }\n  \n  function exit(code) {\n    if (this.window) {\n      remote(\"exit\", code);\n      this.window.close();\n    }\n    else {\n      process.exit(code);\n    }\n  }\n  \n  \n  const macro = function(){\n  /** -------------------------------------------------------------------------------------------------------------------\n   * lib.js\n   */\n  \n  /**\n   * get(path)\n   *  获取指定路径的文本数据\n   */\n  var get = function(fs){\n    if(this.window) {\n      fs = new XMLHttpRequest;\n      return function(path){\n        fs.open('GET', path, false);\n        fs.send();\n        if(!(fs.status / 100 ^ 2))\n          return fs.responseText;\n      }\n    }\n    else {\n      fs = require('fs');\n      return function(path) {\n        return fs.readFileSync(path).toString();\n      }\n    }\n  }();\n  \n  /**\n   * repath(path, rel)\n   *  计算相对路径\n   */\n  var repath = function(path, rel){\n    var rePath = /^(https?:\\/\\/[\\w-.]+(?::\\d+)?|)([\\w\\/.-]+)(.*|)/;\n    var reRel = /^(https?:\\/\\/[\\w-.]+(?::\\d+)?|)(\\/(?:[\\w@.-]+\\/)*)/;\n  \n    function repath(path, rel) {\n      var ms = path.match(rePath);\n      if (ms && !ms[1] && rel && (rel = rel.match(reRel))) {\n        path = ms[2];\n        if (path[0] !== '/') {\n          path = rel[2] + path;\n        }\n        path = rel[1] + normalize(path) + ms[3];\n      }\n      return path;\n    }\n  \n    /** normalize(path) 路径规格化 */\n    var reSlash = /\\/+/;\n  \n    function normalize(src) {\n      var des = [];\n      src = src.split(reSlash);\n      for (var i = 0, l = src.length; i < l; i++) {\n        var sym = src[i];\n        if (des.length) {\n          if (sym !== '.') {\n            var end = des[des.length - 1];\n            if (sym !== '..') {\n              if (end === '.' && sym) des.length--;\n              des.push(sym);\n            }\n            else if (end === '..') {\n              des.push(sym);\n            }\n            else if (end) {\n              des.length--;\n            }\n          }\n        }\n        else {\n          des.push(sym);\n        }\n      }\n      return des.join('/');\n    }\n  \n    return repath;\n  \n  }();\n  \n  var libpath = this.window || function(){\n    var fs = require(\"fs\");\n    var reLibName = /^(?:@[a-z0-9-][a-z0-9-._]*\\/)?[a-z0-9-][a-z0-9-._]*(\\/[^]*)?/;\n  \n    function libpath(name, rel) {\n      var ms = name.match(reLibName);\n      if (!ms)\n        throw Error(\"Error libaray name: '\" + name + \"'\");\n      if(!ms[1]) {\n        name += \"/all.js\";\n      }\n      else if(!name.endsWith(\".js\")) {\n        name += \".js\";\n      }\n    \n      var rel = dirname(rel);\n      while (rel) {\n        var tryname = rel + \"node_modules/\" + name;\n        if (fs.existsSync(tryname))\n          return tryname;\n        rel = dirname(rel.slice(0, -1));\n      }\n  \n      rel = process.env.NODE_PATH;\n      if (rel) {\n        rel = rel.split(\":\");\n        for (var i = 0; i < rel.length; i++) {\n          var dir = rel[i];\n          if (dir) {\n            tryname = dir + \"/\" + name;\n            if (fs.existsSync(tryname))\n              return tryname;\n          }\n        }\n      }\n      throw Error(\"Can't find libaray :'\"+name+\"'\");\n    }\n    \n    function dirname(path) {\n      return path.slice(0, path.lastIndexOf(\"/\") + 1);\n    }\n    return libpath;  \n  }();\n  \n  function isLibName(name) {\n    return /^[^./]/.test(name);\n  }\n  \n  function incpath(path, rel) {\n    if(isLibName(path))\n      return libpath(path, rel);\n    return repath(path, rel);\n  }\n  /** -------------------------------------------------------------------------------------------------------------------\n   * lex.js\n   */\n  \n  const Lex = function () {\n    function $() { return arguments };\n  \n    function regular(any, keys) {\n      if (any instanceof Object) {\n        if (any instanceof RegExp) {\n          any = any.source;\n        }\n        else if (any.length) {\n          var arg = [];\n          for (var i = 0; i < any.length; i++)\n            arg[i] = regular(any[i], keys);\n          // any = arg.join(any.join ? '' : '|');\n          if (any.join) {\n            any = arg.join('');\n          }\n          else {\n            any = arg.join('|');\n            if (arg.length > 1)\n              any = '(?:' + any + ')';\n          }\n        }\n        else {\n          arg = String(Object.keys(any));\n          keys[arg] = keys.$ = (keys.$ | 0) + 1;\n          any = '(' + regular(any[arg], keys) + ')';\n        }\n      }\n      else {\n        any = String(any);\n      }\n      return any;\n    }\n  \n    var keys = Object.create(null);\n    var lex = regular($(\n      { IF: [/\\/\\/#if\\s*\\(/, { COND: /[^)]+/ }, /\\)\\s*{.*\\n?/] },\n      { END: /\\/\\/#}.*\\n?/ },\n      { INCLUDE: [/\\/\\/#include\\s+/, { FILE: /\\S+/ }, /.*/] },\n      { DEFINE: [/\\/\\/#define\\s+/, { DID: /[a-zA-Z_$][\\w$]*/ }, /\\s*/, $([/@\\s*/, { RES: /\\S+/ }, /.*/], [/=\\s*/, { EXP: /.+/ }], { VAL: /.+/ })] },\n      { VAR: [/\\/\\/#var\\s+/, { VID: /[a-zA-Z_$][\\w$]*/ }, /\\s*=\\s*/, { VEXP: /.+/ }] },\n      { TEMP_HEAD: [/`(?:[^`$\\\\]+|\\$(?!{)|\\\\[^])*/, $(/`|$/, { TEMP_OPEN: /\\${/ })] },  //模板头（容错）\n      { TEMP_TAIL: [/}(?:[^`$\\\\]+|\\$(?!{)|\\\\[^])*/, $(/\\${/, { TEMP_CLOSE: /`|$/ })] },  //模板尾（容错）\n      { BLOCK_HEAD: /\\{/ },\n      { BLOCK_TAIL: /\\}/ },\n      { FUNC: /(?:async\\s+)?function\\b[^(]*\\([^)]*\\)/ },\n      { ARROW: /(?:\\([^)]*\\)|[a-zA-Z_$][\\w$]*)\\s*=>/ },\n      { ID: /[a-zA-Z_$][\\w$]*/ },\n      { SQ: /'(?:[^'\\n\\\\]+|\\\\[^])*(?:['\\n]|$)/ },  // 单引号字符串（容错）\n      { DQ: /\"(?:[^\"\\n\\\\]+|\\\\[^])*(?:[\"\\n]|$)/ },  // 双引号字符串（容错）\n      { REGEXP: /\\/(?:\\\\.|\\[(?:\\\\.|[^\\]])*\\]|[^\\/\\*\\n\\r])(?:\\\\.|\\[(?:\\\\.|[^\\]])*\\]|[^/\\n\\r])*?\\/[gimy]*/ },\n      { COMMENT: /\\/\\/.*|\\/\\*[^*]*\\*+(?:[^/][^*]*\\*+)*\\// },\n      { OTHER: /(?:[^{}a-zA-Z_$'\"`/]|\\/(?![/*]))+/ },\n      { SPECIAL: /\\// }\n    ), keys);\n  \n    lex = RegExp(lex + '|', 'g');\n    Lex.$ = keys;\n  \n    function Lex(code) {\n      var $ = keys, re = new RegExp(lex), stack = [], state = 0;\n      return function () {\n        var ms;\n        if (ms = re.exec(code)) {\n          if (ms[$.BLOCK_HEAD]) {\n            stack.push(state);\n            state = $.BLOCK_HEAD;\n          }\n          else if (ms[$.TEMP_HEAD]) {\n            stack.push(state);\n            state = $.TEMP_HEAD;\n          }\n          else if (ms[$.TEMP_TAIL]) {\n            if (state === $.BLOCK_HEAD) {\n              ms[0] = ms[$.BLOCK_TAIL] = \"}\";\n              ms[$.TEMP_TAIL] = ms[$.TEMP_CLOSE] = undefined;\n              re.lastIndex = ms.index + 1;\n              state = stack.pop();\n            }\n            else if (ms[$.TEMP_CLOSE] && state === $.TEMP_HEAD) {\n              state = stack.pop();\n            }\n          }\n          else if (ms[$.BLOCK_TAIL]) {\n            if (state = $.BLOCK_HEAD) {\n              state = stack.pop();\n            }\n          }\n        }\n        return ms;\n      }\n    }\n  \n    return Lex;\n  }();\n  \n  \n  /** -------------------------------------------------------------------------------------------------------------------\n   * make.js\n   */\n  \n  /**\n   * make(path, rel)\n   */\n  var makeFile = function (calc) {\n    calc = this.eval(\"(function(){with(arguments[0])return eval(arguments[1])})\");\n  \n    function makeFile(path, rel, includes, defines, variables, indent) {\n      var code;\n      path = incpath(path, rel);\n      if (includes[path]) {\n        code = '';\n      }\n      else {\n        includes[path] = 1;    // 占位符，防止无限递归\n        code = get(path);\n        if (code)\n          try {\n            code = makeCode(code, path, includes, defines, variables, indent);\n          }\n          catch (e) {\n            if (e instanceof MacroError)\n              e = Error(e.message + ' at (' + path + ':' + rowcol(code, e.index) + ')');\n            throw e;\n          }\n      }\n      return code;\n    }\n  \n    function makeCode(code, rel, includes, defines, variables, indent) {\n      var lex = Lex(code), $ = Lex.$, token, codes = [], id, it;\n      var skip = 0;\n      while (token = lex()) {\n        var s = token[0];\n        if (!s) {\n          if (token.index < code.length)\n            throw new MacroError('Unknown token', token.index);\n          break;\n        }\n  \n        if (token[$.IF]) {\n          if (skip) {\n            skip++;\n          }\n          else {\n            it = token[$.COND];\n            try {\n              if (!calc(variables, it))\n                skip = 1;\n            }\n            catch (e) {\n              skip = 1;\n            }\n          }\n          continue;\n        }\n        if (token[$.END]) {\n          if(skip>0)\n            skip --;\n          continue;\n        }\n        if (skip) continue;\n  \n        if (token[$.INCLUDE]) {\n          var file = token[$.FILE];\n          // if (file = makeFile(file, rel, includes, defines, variables, indentOf(code, token.index)))\n          //   s = file;\n          s = makeFile(file, rel, includes, defines, variables, indentOf(code, token.index));\n        }\n        else if (token[$.DEFINE]) {\n          id = token[$.DID];\n          if (it = token[$.VAL]) {\n            it = it.trim();\n          }\n          else if (it = token[$.RES]) {\n            it = repath(it, rel);\n            try {\n              s = get(it);\n              if (s === undefined)\n                throw Error(\"Read file error: \" + it);\n            }\n            catch (e) {\n              throw new MacroError(e.message, token.index);\n            }\n            it = JSON.stringify(s);\n          }\n          else if (it = token[$.EXP]) {\n            it = calc(variables, it);\n          }\n          defines[id] = variables[id] = it;\n          s = \"//const \" + id + \" = \" + String(it);\n        }\n        else if (token[$.VAR]) {\n          id = token[$.VID];\n          it = token[$.VEXP];\n          it = calc(variables, it);\n          variables[id] = it;\n          s = \"//var \" + id + \" = \" + String(it);\n        }\n        else if (id = token[$.ID]) {\n          if (id in defines) {\n            s = \"/*\" + id + \"*/\" + String(defines[id]);\n          }\n        }\n        else if (token[$.BLOCK_HEAD]) {\n          includes = Object.create(includes);\n          defines = Object.create(defines);\n        }\n        else if (token[$.BLOCK_TAIL]) {\n          var proto = Object.getPrototypeOf(defines);\n          if (proto) defines = proto;\n          var proto = Object.getPrototypeOf(includes);\n          if (proto) includes = proto;\n        }\n        codes[codes.length] = s;\n      }\n      code = codes.join('');\n      code = code.replace(/^/gm, indent).slice(indent.length);\n      return code;\n    }\n  \n    function MacroError(message, index) {\n      this.message = message;\n      this.index = index;\n    }\n  \n    function indentOf(text, index) {\n      for (var i = index; ' \\t'.indexOf(text[i - 1]) >= 0; i--);\n      return text.slice(i, index);\n    }\n  \n    /**\n     * rowcol(text, i)\n     *   计算文本 text 位置 i 的行列值。返回格式 \"row:col\"\n     */\n    function rowcol(text, index) {\n      if (index < 0) return '<EOF>';\n      var reLn = /[\\n\\u2028\\u2029]|\\r\\n?/g;\n      var row = 0, col = 0;\n      while (reLn.exec(text) && index > reLn.lastIndex) {\n        row++;\n        col = reLn.lastIndex;\n      }\n      col = index - col;\n      return (row + 1) + ':' + (col + 1);\n    }\n  \n    return makeFile;\n  }();\n  \n  \n  return function (path, base, variables) {\n    return makeFile(path, base, Object.create(null), Object.create(null), variables || Object.create(null), \"\");\n  }\n  }();\n  \n  \n  /** -------------------------------------------------------------------------------------------------------------------\n   * server.js\n   */\n  \n  function Server() {\n    var xhr = new XMLHttpRequest;\n    var url = location.protocol + \"//\" + location.host + \"//\";\n  \n    return function (oper, value) {\n      xhr.open(\"GET\", url, false);\n      xhr.setRequestHeader(\"oper\", oper);\n      xhr.setRequestHeader(\"value\", encodeURIComponent(value));\n      xhr.send();\n    }\n  };\n  \n\n  this.onerror = function(message, source, lineno, colno, error) {\n    log(\"#e%s\", message);\n  }\n\n  var I = currentScript.getAttribute(\"name\") || \"I\";\n\n  I = global[I] = newI(null, \"\");  // 创建全局的 I，共测试程序使用\n  I.path = location.pathname;\n\n  global.addEventListener(\"load\", async function () {\n    if (cases)\n      try {\n        var tests = cases.split(\",\");\n        for (var i = 0; i < tests.length; i++)\n          await execScript(tests[i]);\n        await I.run();\n        var errs = errors(I);\n      }\n      catch (e) {\n        log(\"#eUncaught %s: %s\", e.name, e.message);\n        errs = -1;\n      }\n      finally {\n        if (!debug) {\n          server(\"exit\", errs);\n          this.close();\n        }\n      }\n    else {\n      await I.run();\n      var errs = errors(I);\n      if (errs) {\n        log(\"#eTOTAL ERRORS: %d !\", errs)\n      }\n      else {\n        log(\"#sALL SUCCESSFUL!\")\n      }\n    }\n\n  });\n\n  async function execScript(src) {\n    return new Promise(function (resolve) {\n      var script = document.createElement(\"script\");\n      script.onload = resolve;\n      script.src = src;\n      try { document.head.appendChild(script) }\n      finally { if(!debug) document.head.removeChild(script) }\n    });\n  }\n})(0, 0, Function, Object, String, Array, RegExp, Date, Error, Promise);\n"
//const AUTOJS = "(function(){\n  const cases=\"\";\n  this.addEventListener(\"load\", function(){\n    var tests = cases.split(\",\");\n    var body = document.body;\n    for(var i=0, test; test=tests[i]; i++) {\n      var script = document.createElement(\"script\");\n      script.setAttribute(\"src\", test);\n      body.appendChild(script);\n    }\n    // script = document.createElement(\"script\");\n    // script.text = \"I.run()\";\n    // body.appendChild(script);\n    script.addEventListener(\"load\", function(){\n      I.run();\n    });\n  });\n})();"

const it = /*ITJS*/"/** -------------------------------------------------------------------------------------------------------------------\n * it.js\n */\n\n(function (global, window, Function, Object, String, Array, RegExp, Date, Error, Promise) {\n  global = this; window = global.window;\n  const currentScript = document.currentScript;\n  const cases = currentScript.getAttribute(\"tests\");\n  const debug = currentScript.hasAttribute(\"debug\");\n  if(!debug) document.head.removeChild(currentScript);\n\n  //const BROWSER = 1\n  /** -----------------------------------------------------------------------------------------------\n   * lib.js\n   */\n  \n  var undefined;\n  \n  /** --------------------------------------------------------------------------\n   * Function\n   */\n  var nop = Function.prototype;\n  var _call = nop.call;\n  var _apply = nop.apply;\n  var _bind = nop.bind;\n  var func = _call.bind(_bind, _call);\n  var bind = func(_bind);\n  var call = func(_call);\n  var apply = func(_apply);\n  \n  function isFunction(any) {\n    return typeof any === 'function';\n  }\n  \n    /** --------------------------------------------------------------------------\n     * Object\n     */\n    var Object_prototype = Object.prototype;\n    var create = Object.create;\n    var getPrototype = Object.getPrototypeOf;\n    var setPrototype = Object.setPrototypeOf;\n    var _isPrototypeOf = Object_prototype.isPrototypeOf;\n  \n    function isObject(any) {\n      return Object(any) === any;    // typeof any === 'object' && any !== nil;\n    }\n  \n    function genusof(any) {\n      return any === null ? \"null\" : typeof any;\n    }\n  \n    var reTrimTag = /\\[object |\\]/g;\n    function tagof(any) {\n      return replace(call(Object_prototype.toString, any), reTrimTag, '');\n    }\n  \n    var hasOwnProperty = func(Object_prototype.hasOwnProperty);\n    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n  \n    function hasProperty(obj, prop) {\n      while (obj) {\n        if (hasOwnProperty(obj, prop))\n          return obj;\n        obj = getPrototype(obj);\n      }\n    }\n  \n    function getPropertyDescriptor(obj, prop) {\n      var desc;\n      while (obj) {\n        if (desc = getOwnPropertyDescriptor(obj, prop))\n          return desc;\n        obj = getPrototype(obj);\n      }\n    }\n  \n    /** --------------------------------------------------------------------------\n     * String\n     */\n    var String_prototype = String.prototype;\n  \n    function isString(any) {\n      return typeof any === 'string';\n    }\n  \n    var trim = func(String_prototype.trim);\n    var replace = func(String_prototype.replace);\n    var match = func(String_prototype.match);\n    var split = func(String_prototype.split);\n    var stringify = JSON.stringify;\n  \n    /** --------------------------------------------------------------------------\n     * Array\n     */\n    var Array_prototype = Array.prototype;\n    var piece = func(Array_prototype.slice);\n    var splice = func(Array_prototype.splice);\n    var push = func(Array_prototype.push);\n    var pop = func(Array_prototype.pop);\n  \n    /** --------------------------------------------------------------------------\n     * RegExp\n     */\n    function isRegExp(any) {\n      return any instanceof RegExp;\n    }\n  \n    /** --------------------------------------------------------------------------\n     * Date\n     */\n    var now = Date.now;\n  \n    /** --------------------------------------------------------------------------\n     * Iterator, Promise, Generator, Async Function\n     */\n    var isIterator = bind(_isPrototypeOf, getPrototype(getPrototype(''[Symbol.iterator]())));\n    var isPromise = bind(_isPrototypeOf, Promise.prototype);\n  \n    function isGeneratorFunction(any) {\n      return tagof(any) === 'GeneratorFunction';\n    }\n  \n    function isAsyncFunction(any) {\n      return tagof(any) === 'AsyncFunction';\n    }\n  \n    function isSyncFunction(any) {\n      return tagof(any) === 'Function';\n    }\n  \n    /** indent(code, spaces) 缩进代码行 */\n    function indent(code, spaces) {\n      return code.replace(/^/gm, spaces);\n    }\n  \n  \n  /** -----------------------------------------------------------------------------------------------\n   * log.js\n   */\n  \n  function report(it) {\n    if (!(it.end = it.parent.end)) {\n      var s = it.topic;\n      if (it.ms) {\n        s += format(\" (timeout #m%dms)\", it.ms);\n      }\n      if (it.fail) {\n        s = format(\"#f✘ %s\\n#e%s%s\", s, indent(it.fail, \"  \"), it.trace ? \"\\n\" + indent(it.trace, \"  #m\") : \"\");\n      }\n      else {\n        s = format(\"#s✔ %s\", s);\n      }\n      log(\"%s\", indent(s, it.indent));\n      it.end = 1;\n    }\n  }\n  \n  function review() {\n    var me = this, it = me.its[me.its.length - 1];\n    if (it && !it.func && !it.end) {\n      var s = '#t• ' + it.topic;\n      if (it.trace)\n        s += indent('\\n#e' + it.trace, '  ');\n      log(indent(s, it.indent));\n    }\n  }\n  \n  function log() {\n    print(format.apply(undefined, arguments));\n  }\n  \n  const server = cases\n    ? Server()\n    : nop;\n  function print(s) {\n    server(\"log\", textcolor(s))\n    console.log.apply(console, argscolor(arguments));\n  }\n  \n  const textcolors = {\n    0: \"\\x1b[0m\",\n    i: \"\\u001b[0m\\u001b[37m\",\n    s: \"\\u001b[1m\\u001b[32m\",\n    f: \"\\u001b[1m\\u001b[31m\",\n    e: \"\\u001b[0m\\u001b[31m\",\n    t: \"\\u001b[1m\\u001b[34m\",\n    m: \"\\u001b[1m\\u001b[30m\"\n  };\n  \n  function textcolor(text) {\n    return replace(text, /#[sftiem]/g, (s) => textcolors[s[1]] || textcolors[0]) + textcolors[0];\n  }\n  \n  const argscolors = {\n    0: \"\",\n    i: \"color:lightgray\",\n    s: \"color:lawngreen;font-weight:900\",\n    f: \"color:tomato;font-weight:900\",\n    e: \"color:red\",\n    t: \"color:royalblue;font-weight:900\",\n    m: \"color:darkgrey\"\n  };\n  \n  function argscolor(args) {\n    var i = 1;\n    args[0] = replace(args[0], /#\\w/g, (s) => (args[i++] = argscolors[s[1]] || \"\", \"%c\"));\n    args.length = i;\n    return args;\n  }\n  \n  function format(s) {\n    var i = 1, args = arguments;\n    return replace(s, /%[sd]/g, function (s) {\n      return i < args.length ? args[i++] : s;\n    });\n  }\n  \n  /** -----------------------------------------------------------------------------------------------\n   * trace.js\n   */\n  \n  /** get(path) 获取文本资源 */\n  var get;\n  \n  if (this.window) {\n    get = function (path) {\n      var http = new XMLHttpRequest;\n      http.open('GET', path, false);\n      http.send();\n      return http.status / 100 ^ 2 ? '' : http.responseText;\n    };\n  }\n  else {\n    const fs = require('fs');\n    get = function (path) {\n      return fs.readFileSync(path, { encoding: 'utf-8' });\n    };\n  }\n  \n  var reWhere = RegExp('\\\\b' + where.name + '\\\\b');\n  var reHere = /((?:https?:\\/\\/[\\w.-]+(?::\\d+)?|)[\\w./@-]+(?:\\?.*|)):(\\d+):(\\d+)/;\n  function where(deep) {\n    var stack = split(Error().stack, \"\\n\");\n    for (var i = 0, line; line = stack[i++];) {\n      if (match(line, reWhere)) break;\n    }\n    if (i < stack.length) {\n      var ms = match(stack[i + deep], reHere);\n      if (ms)\n        return {\n          trace: ms[0],\n          loc: ms[1],\n          row: ms[2] - 1,\n          col: ms[3] - 1\n        };\n    }\n  }\n  \n  var reTrace = /((?:https?:\\/\\/[\\w.-]+(?::\\d+)?|)[\\w./@-]+(?:\\?.*|)):(\\d+):(\\d+)/;\n  function getTrace(error) {\n    var stack = error.stack;\n    if (stack) {\n      stack = split(stack, \"\\n\");\n      for (var i = 0, item; item = stack[i++];) {\n        var ms = match(item, reTrace);\n        if (ms) return ms[0];\n      }\n    }\n  }\n  \n  function getLine(deep) {\n    var here, rows, row;\n    deep += 1;\n    if (here = where(deep)) {\n      if (rows = getRows(here.loc)) {\n        if (row = rows[here.row]) {\n          return { code: row, trace: here.trace }\n        }\n      }\n    }\n  }\n  \n  var cachedRows = {};\n  function getRows(loc) {\n    var rows;\n    if (hasOwnProperty(cachedRows, loc)) {\n      rows = cachedRows[loc];\n    }\n    else {\n      rows = cachedRows[loc] = split(get(loc), \"\\n\");\n    }\n    return rows;\n  }\n  \n  \n  \n  /** -----------------------------------------------------------------------------------------------\n   * assert.js\n   */\n  const EPSILON = 0.0000001192092896;\n  \n  function assert(assert) {\n    var it = newIt(this);\n    if (!assert)\n      it.fail = 'Assert failure!';\n    report(it);\n  }\n  \n  function hope(value) {\n    var it = newIt(this, \"\", value);\n    if (arguments.length > 1)\n      it.args = piece(arguments, 1);\n    return it;\n  }\n  \n  function newIt(parent, topic, value) {\n    call(review, parent);\n    var it = create(itProto);\n    it.parent = parent;\n    var line = getLine(2), code;\n    if (line) {\n      code = trim(line.code);\n      it.trace = line.trace;\n    }\n    it.topic = topic || code || \"unknown testing\"\n    it.value = value;\n    it.indent = parent.indent;\n    it.zero = now();\n    push(parent.its, it);\n    return it;\n  }\n  \n  var itProto = {\n    get be() { return this },\n    get is() {\n      var me = this;\n      var is = setPrototype(newIs(me), newA(me));\n      return setPrototype({ get not() { me.no = 1; return is } }, is);\n    },\n    get not() {\n      this.no = !this.no;\n      return this;\n    },\n  \n    equal: function (expect) { assertEqual(this, normalEqual, 'equals', expect) },\n  \n    get strict() {\n      var me = this;\n      return {\n        equal: function (expect) { assertEqual(me, strictEqual, 'strict equals', expect) }\n      }\n    },\n  \n    get deep() {\n      var me = this;\n      return {\n        equal: function (expect) { assertDeepEqual(me, normalEqual, 'deep equals', expect) },\n        get strict() {\n          return {\n            equal: function (expect) { assertDeepEqual(me, strictEqual, 'deep strict equals', expect) }\n          }\n        }\n      }\n    },\n  \n    get a() { return newA(this) },\n  \n    get has() {\n      var me = this;\n      var has = newHas(me);\n      return setPrototype({ get not() { me.no = 1; return has }, get no() { me.no = 1; return has } }, has);\n    },\n    throw: function () {\n      var me = this, value = me.value, args = arguments, specified, error;\n      if (specified = args.length) error = args[0];\n      args = me.args;\n      if (assertFunction(me)) {\n        if (isSyncFunction(value)) {\n          try {\n            apply(value, undefined, args);\n            assertThrow(me, specified, error);\n          }\n          catch (except) {\n            assertThrow(me, specified, error, except);\n          }\n        }\n        else if (isGeneratorFunction(value)) {\n          return apply(go, undefined, union([value], args))\n            .then(function () {\n              assertThrow(me, specified, error);\n            })\n            .catch(function (except) {\n              assertThrow(me, specified, error, except);\n            });\n        }\n        else if (isAsyncFunction(value)) {\n          return apply(value, undefined, args)\n            .then(function () {\n              assertThrow(me, specified, error);\n            })\n            .catch(function (except) {\n              assertThrow(me, specified, error, except);\n            });\n        }\n      }\n    }\n  };\n  \n  function newIs(me) {\n    return {\n      get undefined() { return assertValue(me, me.value === undefined, 'undefined') },\n      get null() { return assertValue(me, me.value === null, 'null') },\n      get void() { return assertValue(me, me.value === undefined || me.value === null, 'void') },\n      get ok() { return assertValue(me, me.value, 'ok') },\n      get NaN() { return assertValue(me, me.value !== me.value, 'NaN') },\n      get finite() { return assertValue(me, Number.isFinite(me.value), 'finite') },\n      get a() { return newA(me) },\n      get an() { return newA(me) },\n      equal: function (expect) { assertEqual(me, normalEqual, 'equal to', expect) },\n      get strict() {\n        return {\n          equal: function (expect) { assertEqual(me, strictEqual, 'strict equal to', expect) }\n        }\n      },\n      get deep() {\n        return {\n          equal: function (expect) { assertDeepEqual(me, normalEqual, 'deep equal to', expect) },\n          get strict() {\n            return {\n              equal: function (expect) { assertDeepEqual(me, strictEqual, 'deep strict equal to', expect) }\n            }\n          }\n        }\n      },\n    };\n  }\n  \n  function newHas(me) {\n    return {\n      property: function (property) { assertHasProperty(me, property) },\n      get own() {\n        return {\n          property: function (property) { assertHasOwnProperty(me, property) },\n          get enumerable() {\n            return {\n              property: function (property) { assertHasOwnEnumerableProperty(me, property) }\n            }\n          }\n        }\n      },\n      get enumerable() {\n        return {\n          property: function (property) { assertHasEnumerableProperty(me, property) }\n        }\n      }\n    }\n  }\n  \n  function newA(me) {\n    return {\n      get boolean() { assertType(me, 'boolean') },\n      get number() { assertType(me, 'number') },\n      get string() { assertType(me, 'string') },\n      get symbol() { assertType(me, 'symbol') },\n      get object() { assertType(me, 'object') },\n      get function() { assertType(me, 'function') },\n      get Object() { assertInstance(me, Object) },\n      get Function() { assertInstance(me, Function) },\n      get Boolean() { assertInstance(me, Boolean) },\n      get Number() { assertInstance(me, Number) },\n      get String() { assertInstance(me, String) },\n      get Array() { assertInstance(me, Array) },\n      get RegExp() { assertInstance(me, RegExp) },\n      get Date() { assertInstance(me, Date) },\n      get Error() { assertInstance(me, Error) },\n      get Set() { assertInstance(me, Set) },\n      get WeakSet() { assertInstance(me, WeakSet) },\n      get Map() { assertInstance(me, Map) },\n      get WeakMap() { assertInstance(me, WeakMap) },\n      get Arguments() { assertTag(me, 'Arguments') },\n      get Iterator() { assertInstanceOf(me, isIterator(me.value), 'Iterator') },\n      get Promise() { assertInstance(me, Promise) },\n      get Generator() { assertTag(me, 'Generator') },\n      get GeneratorFunction() { assertTag(me, 'GeneratorFunction') },\n      get AsyncFunction() { assertTag(me, 'AsyncFunction') },\n      get instance() { return { of: function (type) { assertInstance(me, type) } } }\n    };\n  }\n  \n  function assertValue(it, assert, verb) {\n    if (!assert ^ it.no)\n      it.fail = disappoint(textify(it.value), 'is', it.no, verb);\n    report(it);\n  }\n  \n  function assertEqual(it, compare, verb, expect) {\n    var value = it.value, not = it.no, assert;\n    assert = compare(value, expect);\n    if (!assert ^ not) {\n      var type = typeclass(value);\n      if (match(type, /^[A-Z]|symbol/) && type === typeclass(expect))\n        verb += not ? ' the same' : ' another';\n      it.fail = \"hope \" + textify(value) + ' is ' + (not ? 'not ' : '') + verb + ' ' + textify(expect) + '.';\n    }\n    report(it);\n  }\n  \n  function assertDeepEqual(it, compare, verb, expect) {\n    var value = it.value, not = it.no, assert, dif;\n    dif = diff(value, expect, compare);\n    if (!!dif ^ not)\n      it.fail = \"hope \" + textify(value) + ' is ' + (not ? 'not ' : '') + verb + ' ' + textify(expect) + '.'\n        + '\\n' + (dif ? dif : 'there is no different for ' + verb + '.');\n    report(it);\n  }\n  \n  \n  \n  function assertType(it, type) {\n    if ((genusof(it.value) !== type) ^ it.no)\n      it.fail = disappoint(textify(it.value), 'is', it.no, 'type as', type);\n    report(it);\n  }\n  \n  function assertInstance(it, type) {\n    if (isFunction(type)) {\n      assertInstanceOf(it, isFunction(type) && it.value instanceof type, funcname(type));\n    }\n    else {\n      it.fail = 'Error: ' + textify(type) + ' is not callable.';\n      report(it);\n    }\n  }\n  \n  function assertTag(it, type) {\n    assertInstanceOf(it, tagof(it.value) === type, type);\n  }\n  \n  function assertInstanceOf(it, assert, type) {\n    if (!assert ^ it.no)\n      it.fail = disappoint(textify(it.value), 'is', it.no, 'an instance of', type);\n    report(it);\n  }\n  \n  function disappoint(one, vi, not, vt, other) {\n    return 'Hope ' + one + ' ' + vi + (not ? ' not ' : ' ') + vt + (other ? ' ' + other : '') + '.';\n  }\n  \n  function assertHasProperty(it, property) {\n    if (assertObject(it)) {\n      assertProperty(it, property in it.value, 'property', property);\n    }\n  }\n  \n  function assertHasOwnProperty(it, property) {\n    if (assertObject(it)) {\n      assertProperty(it, hasOwnProperty(it.value, property), 'own property', property);\n    }\n  }\n  \n  function assertHasEnumerableProperty(it, property) {\n    if (assertObject(it)) {\n      var desc = getPropertyDescriptor(it.value, property);\n      assertProperty(it, desc && desc.enumerable, 'enumerable property', property);\n    }\n  }\n  \n  function assertHasOwnEnumerableProperty(it, property) {\n    if (assertObject(it)) {\n      var desc = getOwnPropertyDescriptor(it.value, property);\n      assertProperty(it, desc && desc.enumerable, 'own enumerable property', property);\n    }\n  }\n  \n  function assertProperty(it, assert, verb, property) {\n    var no = it.no;\n    if (!assert ^ no)\n      it.fail = 'But ' + textify(it.value) + ' has ' + (no ? '' : 'no ') + verb + ' ' + stringify(property) + '.';\n    report(it);\n  }\n  \n  function assertObject(it) {\n    return isObject(it.value) || (it.fail = 'But ' + textify(it.value) + ' is not an object!', report(it));\n  }\n  \n  function assertFunction(it) {\n    return isFunction(it.value) || (it.fail = 'But ' + textify(it.value) + ' is not a function!', report(it))\n  }\n  \n  function assertThrow(it, specified, error, except) {\n    var not = it.no, ok = arguments.length < 4;\n  \n    if (ok) {\n      if (!not)\n        it.fail = fail(specified ? textify(error) : '', textify(except));\n    }\n    else if (specified) {\n      if (isFunction(error)) {\n        if (!(except instanceof error) ^ not)\n          it.fail = fail(funcname(error) + ' object', textify(except));\n      }\n      else if (isString(error)) {\n        error = stringify(error);\n        if (isString(except)) {\n          except = stringify(except);\n        }\n        else if (isObject(except)) {\n          if (hasProperty(except, 'message')) {\n            except = stringify(except.message);\n          }\n          else {\n            except = textify(except);\n          }\n        }\n        else {\n          except = textify(except);\n        }\n        if ((error !== except) ^ not)\n          it.fail = fail(error, except);\n      }\n      else if ((error !== except) ^ not) {\n        it.fail = fail(textify(error), textify(except));\n      }\n    }\n    else if (not) {\n      it.fail = fail('', textify(except));\n    }\n    report(it);\n  \n    function fail(error, except) { return 'Hope' + (not ? ' not' : '') + ' throw ' + (error && error + ' ') + 'but throw ' + (ok ? 'nothing' : except) + '.' };\n  }\n  \n  function typeclass(any) {\n    var type = genusof(any), proto;\n    if (type === 'object' || type === 'function') {\n      if (proto = getPrototype(any)) {\n        if (hasOwnProperty(proto, 'constructor')) {\n          type = funcname(proto.constructor);\n        }\n        else {\n          type = tagof(any);\n        }\n      }\n      else {\n        type = 'null prototype';\n      }\n    }\n    return type;\n  }\n  \n  function funcname(any) {\n    return isFunction(any) ?\n      any.name || '[anonymous]' : '';\n  }\n  \n  function normalEqual(a, b) { return a == b || typeof a === \"number\" && typeof b === \"number\" && EPSILON >= a-b && a-b>=-EPSILON }\n  \n  function strictEqual(a, b) { return a === b || typeof a === \"number\" && typeof b === \"number\" && EPSILON >= a-b && a-b>=-EPSILON }\n  \n  function textify(any) {\n    var s = typeclass(any);\n    if (s === 'string' || s === 'boolean') {\n      s += ' ' + stringify(any);\n    }\n    else if (s === 'number' || s === 'symbol') {\n      s += ' ' + String(any);\n    }\n    else if (s === 'Date' || s === 'String' || s === 'Number' || s === 'Boolean') {\n      s += ' ' + stringify(any.valueOf());\n    }\n    else if (s === 'null prototype') {\n      s = 'object with ' + s;\n    }\n    else if (s !== 'undefined' && s !== 'null') {\n      s += ' object';\n    }\n    return s;\n  }\n  \n  function diff(a, b, equal) {\n    var aValue, bValue;\n    if (!equal(a, b)) {\n      if (isObject(a) && isObject(b)) {\n        if (isRegExp(a) && isRegExp(b)) {\n          aValue = a.toString(), bValue = b.toString();\n          if (!equal(aValue, bValue))\n            return ': one is ' + aValue + ', the other is ' + bValue + '.';\n        }\n        var aKeys = Object.keys(a), bKeys = Object.keys(b);\n        var i = aKeys.length, length = bKeys.length;\n        if (i > length)\n          length = i;\n        aKeys.sort();\n        bKeys.sort();\n        var aKey, bKey;\n        for (i = 0; i < length && (aKey = aKeys[i]) === (bKey = bKeys[i]); i++) {\n          aValue = a[aKey], bValue = b[bKey];\n          var dif = diff(aValue, bValue, equal);\n          if (dif) {\n            return propexp(aKey) + dif;\n          }\n        }\n        if (aKey !== bKey) {\n          if (aKey < bKey || bKey === undefined) {\n            return propexp(aKey) + ': one is ' + textify(a[aKey]) + ', the other is absent.';\n          }\n          if (bKey < aKey || aKey === undefined) {\n            return propexp(bKey) + ': one is absent, the other is ' + textify(b[bKey]) + '.';\n          }\n        }\n      }\n      else {\n        return ': one is ' + textify(a) + ', the other is ' + textify(b);\n      }\n    }\n  \n    function propexp(prop) {\n      if (match(prop, /[a-zA-Z_$][\\w$]*/))\n        return '.' + prop;\n      if (match(prop, /^0$|^[1-9]\\d*$/))\n        return '[' + prop + ']';\n      return '[' + stringify(prop) + ']';\n    }\n  }\n  \n  \n  /** -----------------------------------------------------------------------------------------------\n   * go.js\n   */\n  \n  function go(gen) {\n    var self = this;\n    var args = piece(arguments, 1);\n  \n    return new Promise(function (resolve, reject) {\n      if (typeof gen === \"function\")\n        gen = gen.apply(self, args);\n      if (!gen || typeof gen.next !== \"function\")\n        return resolve(gen);\n  \n      goon();\n  \n      function goon(value) {\n        var state;\n        try {\n          state = gen.next(value);\n        }\n        catch (e) {\n          return reject(e);\n        }\n        next(state);\n      }\n  \n      function stop(err) {\n        var state;\n        try {\n          state = gen.throw(err);\n        }\n        catch (e) {\n          return reject(e);\n        }\n        next(state);\n      }\n  \n      function next(state) {\n        if (state.done)\n          return resolve(state.value);\n        var value = state.value;\n        if (isPromise(value)) {\n          value.then(goon, stop);\n        }\n        else {\n          goon(value);\n        }\n      }\n    })\n  }\n  \n  \n  /** -----------------------------------------------------------------------------------------------\n   * run.js\n   */\n  \n  function Timeout(I) {\n    this.I = I;\n  }\n  \n  function checktime(me) {\n    var I = me;\n    while (I) {\n      if (now() - I.zero >= I.timeout) {\n        throw new Timeout(I);\n      }\n      I = I.parent;\n    }\n    return me;\n  }\n  \n  async function run() {\n    var me = this, func = me.func;\n    var topic = me.topic;\n    if (me.timeout)\n      topic += format(\"(#t%dms)\", me.ms);\n    me.zero = now();\n    try {\n      if (isSyncFunction(func)) {\n        if (func.name !== '$') {\n          print(indent(topic, me.parent.indent));\n          func(me);\n        }\n        else {\n          await new Promise(function (goon) {\n            var it = newIt(me.parent, topic);\n            me.parent.do = function () {\n              if (!it.end) {\n                reporting();\n                iProto.do.apply(me, arguments);\n                goon();\n              }\n            }\n            func(done);\n  \n            function done(err) {\n              if (!it.end) {\n                reporting(err);\n                goon();\n              }\n            }\n            function reporting(err) {\n              if (err) {\n                it.fail = err instanceof Error ? err.message : String(err);\n              }\n              report(it);\n            }\n          });\n        }\n      }\n      else if (isGeneratorFunction(func)) {\n        print(indent(topic, me.parent.indent));\n        await go(func, me);\n      }\n      else if (isAsyncFunction(func)) {\n        print(indent(topic, me.parent.indent));\n        await func(me);\n      }\n  \n      var us = me.us;\n      for (var i = 0; i < us.length; i++)\n        await us[i].run();\n      summarize(me);\n    }\n    catch (err) {\n      var s;\n      if (err instanceof Timeout) {\n        if (err.I !== me) throw err;  // 若不是本层任务超时，则抛出至上层处理。\n        s = indent(format('#e⦸ Timeout Error: %dms!', err.I.timeout), err.I.indent);\n      }\n      else {\n        s = format('#e⦸ %s: %s', err.name, err.message);\n        var trace = getTrace(err);\n        if (trace)\n          s += \"\\n  \" + trace;\n        s = indent(s, me.indent);\n      }\n      print(s);\n      me.end = 1;\n    }\n  }\n  \n  function summarize(me) {\n    var s = sum(me);\n    var total = s.total, okey = s.okey, fail = s.fail, miss = s.miss;\n    s = format(\"#t✈#i Total asserts: #t%d#i,\", total);\n    if (okey) {\n      s += format(' okey: #s%d%s#i,', okey, rate(okey));\n    }\n    if (fail) {\n      s += format(' fail: #f%d%s#i,', fail, rate(fail));\n    }\n    if (miss) {\n      s += format(' miss: #t%d%s#i,', miss, rate(miss));\n    }\n  \n    s += format(\" duration: #t%d#ims.\", now() - me.zero);\n    print(indent(s, me.indent));\n  \n    function rate(value) {\n      return Number.isInteger(value = value / total * 100) ? '(' + value + '%)' : '';\n    }\n  }\n  \n  function sum(me) {\n    var its = me.its, total = its.length, okey = 0, fail = 0, miss = 0;\n    for (var i = 0; i < total; i++) {\n      var it = its[i];\n      if (it.end) {\n        if (it.fail) {\n          fail++;\n        }\n        else {\n          okey++;\n        }\n      }\n      else {\n        miss++;\n      }\n    }\n    its = me.us;\n    for(var i=0; i<its.length; i++) {\n      me = sum(its[i]);\n      total += me.total;\n      okey += me.okey;\n      fail += me.fail;\n      miss += me.miss;\n    }\n    return {total, okey, fail, miss};\n  }\n  \n  function errors(me) {\n    var errs = 0, its = me.its, us = me.us;\n    for (var i = 0; i < its.length; i++) {\n      var it = its[i];\n      if (it.end) {\n        if (it.fail)\n          errs++;\n      }\n      else {\n        errs++;\n      }\n    }\n    for (var i = 0; i < us.length; i++)\n      errs += errors(us[i]);\n    return errs;\n  } \n  \n  /** -----------------------------------------------------------------------------------------------\n   * i.js\n   */\n  \n  function newI(parent, topic, func, timeout) {\n    var I = create(iProto);\n    I.parent = parent;\n    I.topic = topic;\n    I.func = func;\n    I.timeout = timeout;\n    I.us = [];\n    I.its = [];\n    if (parent) {\n      I.indent = parent.indent + \"  \";\n      I.path = parent.path;\n    }\n    else {\n      I.indent = \"\";\n    }\n    return I;\n  }\n  \n  const iProto = {\n    do: function (topic, func, timeout) {\n      push(this.us, newI(this, topic, func, timeout));\n    },\n  \n    log: function (s) {\n      var me = checktime(this);\n      s = apply(format, undefined, arguments);\n      print(indent(s, me.indent));\n    },\n  \n    delay: async function (ms) {\n      var me = checktime(this);\n      var I = me;\n      while (I) {\n        var left = I.timeout + I.zero - now();\n        if (left < ms)\n          ms = left;\n        I = I.parent;\n      }\n      if (ms >= 0)\n        await new Promise(function (resolve) {\n          setTimeout(resolve, ms);\n        });\n    },\n    assert: assert,\n    get am() {\n      var me = this;\n      return { sure: bind(assert, me) };\n    },\n    hope: hope,\n    say: say,\n    run: run\n  };\n  \n  function say(topic) {\n    var me = this;\n    var it = newIt(me, topic);\n    return {\n      if: function (assert) {\n        if (!assert)\n          it.fail = 'Assert failure!';\n        report(it);\n      },\n      as: function (value) {\n        it.value = value;\n        return it;\n      },\n      on: function on(func) {\n        try {\n          func();\n        }\n        catch (err) {\n          it.fail = 'Throw ' + String(err);\n        }\n        report(it);\n      }\n    };\n  }\n  \n  \n  /** -----------------------------------------------------------------------------------------------\n   * load.js\n   */\n  \n  (function () {\n    iProto.get = function (url) {\n      url = purl(url, this.path);\n      return get(url);\n    };\n  \n    var jsed = {};\n    iProto.js = function (url) {\n      url = purl(url, this.path);\n      if (!jsed[url]) {\n        jsed[url] = 1;\n        var code = get(url) + '\\n//# sourceURL=' + url;\n        var path = this.path;\n        this.path = url;\n        try {\n          global.eval(code);\n        }\n        finally {\n          this.path = path;\n        }\n      }\n    }\n  \n    /** purl(url, rel)  计算相对路径并规格化 */\n    var reUrl = /^(https?:\\/\\/[\\w-.]+(?::\\d+)?|)([\\w\\/.-]+)(.*|)/;\n    var reRel = /^(https?:\\/\\/[\\w-.]+(?::\\d+)?|)(\\/(?:[\\w.-]+\\/)*)/;\n  \n    function purl(url, rel) {\n      var ms = match(url, reUrl);\n      if (ms && !ms[1] && (rel = match(rel, reRel))) {\n        url = ms[2];\n        if (url[0] !== '/') {\n          url = rel[2] + url;\n        }\n        url = rel[1] + furl(url) + ms[3];\n      }\n      return url;\n    }\n  \n    /** furl(url) 路径规格化 */\n    var reSlash = /\\/+/;\n  \n    function furl(src) {\n      var des = [];\n      src = split(src, reSlash);\n      for (var i = 0, l = src.length; i < l; i++) {\n        var sym = src[i];\n        if (des.length) {\n          if (sym !== '.') {\n            var end = des[des.length - 1];\n            if (sym !== '..') {\n              if (end === '.' && sym) pop(des);\n              push(des, sym);\n            }\n            else if (end === '..') {\n              push(des, sym);\n            }\n            else if (end) {\n              pop(des);\n            }\n          }\n        }\n        else {\n          push(des, sym);\n        }\n      }\n      return des.join('/');\n    }\n  })();\n  \n  \n  \n  \n  /** -----------------------------------------------------------------------------------------------\n   * main.js\n   */\n  \n  async function main() {\n    try {\n      await I.run();\n      exit(errors(I));\n    }\n    catch (e) {\n      log(\"#eUncaught %s: %s\", e.name, e.message);\n      exit(-1);\n    }\n  }\n  \n  function exit(code) {\n    if (this.window) {\n      remote(\"exit\", code);\n      this.window.close();\n    }\n    else {\n      process.exit(code);\n    }\n  }\n  \n  \n  const macro = function(){\n  /** -------------------------------------------------------------------------------------------------------------------\n   * lib.js\n   */\n  \n  /**\n   * get(path)\n   *  获取指定路径的文本数据\n   */\n  var get = function(fs){\n    if(this.window) {\n      fs = new XMLHttpRequest;\n      return function(path){\n        fs.open('GET', path, false);\n        fs.send();\n        if(!(fs.status / 100 ^ 2))\n          return fs.responseText;\n      }\n    }\n    else {\n      fs = require('fs');\n      return function(path) {\n        return fs.readFileSync(path).toString();\n      }\n    }\n  }();\n  \n  /**\n   * repath(path, rel)\n   *  计算相对路径\n   */\n  var repath = function(path, rel){\n    var rePath = /^(https?:\\/\\/[\\w-.]+(?::\\d+)?|)([\\w\\/.-]+)(.*|)/;\n    var reRel = /^(https?:\\/\\/[\\w-.]+(?::\\d+)?|)(\\/(?:[\\w@.-]+\\/)*)/;\n  \n    function repath(path, rel) {\n      var ms = path.match(rePath);\n      if (ms && !ms[1] && rel && (rel = rel.match(reRel))) {\n        path = ms[2];\n        if (path[0] !== '/') {\n          path = rel[2] + path;\n        }\n        path = rel[1] + normalize(path) + ms[3];\n      }\n      return path;\n    }\n  \n    /** normalize(path) 路径规格化 */\n    var reSlash = /\\/+/;\n  \n    function normalize(src) {\n      var des = [];\n      src = src.split(reSlash);\n      for (var i = 0, l = src.length; i < l; i++) {\n        var sym = src[i];\n        if (des.length) {\n          if (sym !== '.') {\n            var end = des[des.length - 1];\n            if (sym !== '..') {\n              if (end === '.' && sym) des.length--;\n              des.push(sym);\n            }\n            else if (end === '..') {\n              des.push(sym);\n            }\n            else if (end) {\n              des.length--;\n            }\n          }\n        }\n        else {\n          des.push(sym);\n        }\n      }\n      return des.join('/');\n    }\n  \n    return repath;\n  \n  }();\n  \n  var libpath = this.window || function(){\n    var fs = require(\"fs\");\n    var reLibName = /^(?:@[a-z0-9-][a-z0-9-._]*\\/)?[a-z0-9-][a-z0-9-._]*(\\/[^]*)?/;\n  \n    function libpath(name, rel) {\n      var ms = name.match(reLibName);\n      if (!ms)\n        throw Error(\"Error libaray name: '\" + name + \"'\");\n      if(!ms[1]) {\n        name += \"/all.js\";\n      }\n      else if(!name.endsWith(\".js\")) {\n        name += \".js\";\n      }\n    \n      var rel = dirname(rel);\n      while (rel) {\n        var tryname = rel + \"node_modules/\" + name;\n        if (fs.existsSync(tryname))\n          return tryname;\n        rel = dirname(rel.slice(0, -1));\n      }\n  \n      rel = process.env.NODE_PATH;\n      if (rel) {\n        rel = rel.split(\":\");\n        for (var i = 0; i < rel.length; i++) {\n          var dir = rel[i];\n          if (dir) {\n            tryname = dir + \"/\" + name;\n            if (fs.existsSync(tryname))\n              return tryname;\n          }\n        }\n      }\n      throw Error(\"Can't find libaray :'\"+name+\"'\");\n    }\n    \n    function dirname(path) {\n      return path.slice(0, path.lastIndexOf(\"/\") + 1);\n    }\n    return libpath;  \n  }();\n  \n  function isLibName(name) {\n    return /^[^./]/.test(name);\n  }\n  \n  function incpath(path, rel) {\n    if(isLibName(path))\n      return libpath(path, rel);\n    return repath(path, rel);\n  }\n  /** -------------------------------------------------------------------------------------------------------------------\n   * lex.js\n   */\n  \n  const Lex = function () {\n    function $() { return arguments };\n  \n    function regular(any, keys) {\n      if (any instanceof Object) {\n        if (any instanceof RegExp) {\n          any = any.source;\n        }\n        else if (any.length) {\n          var arg = [];\n          for (var i = 0; i < any.length; i++)\n            arg[i] = regular(any[i], keys);\n          // any = arg.join(any.join ? '' : '|');\n          if (any.join) {\n            any = arg.join('');\n          }\n          else {\n            any = arg.join('|');\n            if (arg.length > 1)\n              any = '(?:' + any + ')';\n          }\n        }\n        else {\n          arg = String(Object.keys(any));\n          keys[arg] = keys.$ = (keys.$ | 0) + 1;\n          any = '(' + regular(any[arg], keys) + ')';\n        }\n      }\n      else {\n        any = String(any);\n      }\n      return any;\n    }\n  \n    var keys = Object.create(null);\n    var lex = regular($(\n      { IF: [/\\/\\/#if\\s*\\(/, { COND: /[^)]+/ }, /\\)\\s*{.*\\n?/] },\n      { END: /\\/\\/#}.*\\n?/ },\n      { INCLUDE: [/\\/\\/#include\\s+/, { FILE: /\\S+/ }, /.*/] },\n      { DEFINE: [/\\/\\/#define\\s+/, { DID: /[a-zA-Z_$][\\w$]*/ }, /\\s*/, $([/@\\s*/, { RES: /\\S+/ }, /.*/], [/=\\s*/, { EXP: /.+/ }], { VAL: /.+/ })] },\n      { VAR: [/\\/\\/#var\\s+/, { VID: /[a-zA-Z_$][\\w$]*/ }, /\\s*=\\s*/, { VEXP: /.+/ }] },\n      { TEMP_HEAD: [/`(?:[^`$\\\\]+|\\$(?!{)|\\\\[^])*/, $(/`|$/, { TEMP_OPEN: /\\${/ })] },  //模板头（容错）\n      { TEMP_TAIL: [/}(?:[^`$\\\\]+|\\$(?!{)|\\\\[^])*/, $(/\\${/, { TEMP_CLOSE: /`|$/ })] },  //模板尾（容错）\n      { BLOCK_HEAD: /\\{/ },\n      { BLOCK_TAIL: /\\}/ },\n      { FUNC: /(?:async\\s+)?function\\b[^(]*\\([^)]*\\)/ },\n      { ARROW: /(?:\\([^)]*\\)|[a-zA-Z_$][\\w$]*)\\s*=>/ },\n      { ID: /[a-zA-Z_$][\\w$]*/ },\n      { SQ: /'(?:[^'\\n\\\\]+|\\\\[^])*(?:['\\n]|$)/ },  // 单引号字符串（容错）\n      { DQ: /\"(?:[^\"\\n\\\\]+|\\\\[^])*(?:[\"\\n]|$)/ },  // 双引号字符串（容错）\n      { REGEXP: /\\/(?:\\\\.|\\[(?:\\\\.|[^\\]])*\\]|[^\\/\\*\\n\\r])(?:\\\\.|\\[(?:\\\\.|[^\\]])*\\]|[^/\\n\\r])*?\\/[gimy]*/ },\n      { COMMENT: /\\/\\/.*|\\/\\*[^*]*\\*+(?:[^/][^*]*\\*+)*\\// },\n      { OTHER: /(?:[^{}a-zA-Z_$'\"`/]|\\/(?![/*]))+/ },\n      { SPECIAL: /\\// }\n    ), keys);\n  \n    lex = RegExp(lex + '|', 'g');\n    Lex.$ = keys;\n  \n    function Lex(code) {\n      var $ = keys, re = new RegExp(lex), stack = [], state = 0;\n      return function () {\n        var ms;\n        if (ms = re.exec(code)) {\n          if (ms[$.BLOCK_HEAD]) {\n            stack.push(state);\n            state = $.BLOCK_HEAD;\n          }\n          else if (ms[$.TEMP_HEAD]) {\n            stack.push(state);\n            state = $.TEMP_HEAD;\n          }\n          else if (ms[$.TEMP_TAIL]) {\n            if (state === $.BLOCK_HEAD) {\n              ms[0] = ms[$.BLOCK_TAIL] = \"}\";\n              ms[$.TEMP_TAIL] = ms[$.TEMP_CLOSE] = undefined;\n              re.lastIndex = ms.index + 1;\n              state = stack.pop();\n            }\n            else if (ms[$.TEMP_CLOSE] && state === $.TEMP_HEAD) {\n              state = stack.pop();\n            }\n          }\n          else if (ms[$.BLOCK_TAIL]) {\n            if (state = $.BLOCK_HEAD) {\n              state = stack.pop();\n            }\n          }\n        }\n        return ms;\n      }\n    }\n  \n    return Lex;\n  }();\n  \n  \n  /** -------------------------------------------------------------------------------------------------------------------\n   * make.js\n   */\n  \n  /**\n   * make(path, rel)\n   */\n  var makeFile = function (calc) {\n    calc = this.eval(\"(function(){with(arguments[0])return eval(arguments[1])})\");\n  \n    function makeFile(path, rel, includes, defines, variables, indent) {\n      var code;\n      path = incpath(path, rel);\n      if (includes[path]) {\n        code = '';\n      }\n      else {\n        includes[path] = 1;    // 占位符，防止无限递归\n        code = get(path);\n        if (code)\n          try {\n            code = makeCode(code, path, includes, defines, variables, indent);\n          }\n          catch (e) {\n            if (e instanceof MacroError)\n              e = Error(e.message + ' at (' + path + ':' + rowcol(code, e.index) + ')');\n            throw e;\n          }\n      }\n      return code;\n    }\n  \n    function makeCode(code, rel, includes, defines, variables, indent) {\n      var lex = Lex(code), $ = Lex.$, token, codes = [], id, it;\n      var skip = 0;\n      while (token = lex()) {\n        var s = token[0];\n        if (!s) {\n          if (token.index < code.length)\n            throw new MacroError('Unknown token', token.index);\n          break;\n        }\n  \n        if (token[$.IF]) {\n          if (skip) {\n            skip++;\n          }\n          else {\n            it = token[$.COND];\n            try {\n              if (!calc(variables, it))\n                skip = 1;\n            }\n            catch (e) {\n              skip = 1;\n            }\n          }\n          continue;\n        }\n        if (token[$.END]) {\n          if(skip>0)\n            skip --;\n          continue;\n        }\n        if (skip) continue;\n  \n        if (token[$.INCLUDE]) {\n          var file = token[$.FILE];\n          // if (file = makeFile(file, rel, includes, defines, variables, indentOf(code, token.index)))\n          //   s = file;\n          s = makeFile(file, rel, includes, defines, variables, indentOf(code, token.index));\n        }\n        else if (token[$.DEFINE]) {\n          id = token[$.DID];\n          if (it = token[$.VAL]) {\n            it = it.trim();\n          }\n          else if (it = token[$.RES]) {\n            it = repath(it, rel);\n            try {\n              s = get(it);\n              if (s === undefined)\n                throw Error(\"Read file error: \" + it);\n            }\n            catch (e) {\n              throw new MacroError(e.message, token.index);\n            }\n            it = JSON.stringify(s);\n          }\n          else if (it = token[$.EXP]) {\n            it = calc(variables, it);\n          }\n          defines[id] = variables[id] = it;\n          s = \"//const \" + id + \" = \" + String(it);\n        }\n        else if (token[$.VAR]) {\n          id = token[$.VID];\n          it = token[$.VEXP];\n          it = calc(variables, it);\n          variables[id] = it;\n          s = \"//var \" + id + \" = \" + String(it);\n        }\n        else if (id = token[$.ID]) {\n          if (id in defines) {\n            s = \"/*\" + id + \"*/\" + String(defines[id]);\n          }\n        }\n        else if (token[$.BLOCK_HEAD]) {\n          includes = Object.create(includes);\n          defines = Object.create(defines);\n        }\n        else if (token[$.BLOCK_TAIL]) {\n          var proto = Object.getPrototypeOf(defines);\n          if (proto) defines = proto;\n          var proto = Object.getPrototypeOf(includes);\n          if (proto) includes = proto;\n        }\n        codes[codes.length] = s;\n      }\n      code = codes.join('');\n      code = code.replace(/^/gm, indent).slice(indent.length);\n      return code;\n    }\n  \n    function MacroError(message, index) {\n      this.message = message;\n      this.index = index;\n    }\n  \n    function indentOf(text, index) {\n      for (var i = index; ' \\t'.indexOf(text[i - 1]) >= 0; i--);\n      return text.slice(i, index);\n    }\n  \n    /**\n     * rowcol(text, i)\n     *   计算文本 text 位置 i 的行列值。返回格式 \"row:col\"\n     */\n    function rowcol(text, index) {\n      if (index < 0) return '<EOF>';\n      var reLn = /[\\n\\u2028\\u2029]|\\r\\n?/g;\n      var row = 0, col = 0;\n      while (reLn.exec(text) && index > reLn.lastIndex) {\n        row++;\n        col = reLn.lastIndex;\n      }\n      col = index - col;\n      return (row + 1) + ':' + (col + 1);\n    }\n  \n    return makeFile;\n  }();\n  \n  \n  return function (path, base, variables) {\n    return makeFile(path, base, Object.create(null), Object.create(null), variables || Object.create(null), \"\");\n  }\n  }();\n  \n  \n  /** -------------------------------------------------------------------------------------------------------------------\n   * server.js\n   */\n  \n  function Server() {\n    var xhr = new XMLHttpRequest;\n    var url = location.protocol + \"//\" + location.host + \"//\";\n  \n    return function (oper, value) {\n      xhr.open(\"GET\", url, false);\n      xhr.setRequestHeader(\"oper\", oper);\n      xhr.setRequestHeader(\"value\", encodeURIComponent(value));\n      xhr.send();\n    }\n  };\n  \n\n  this.onerror = function(message, source, lineno, colno, error) {\n    log(\"#e%s\", message);\n  }\n\n  var I = currentScript.getAttribute(\"name\") || \"I\";\n\n  I = global[I] = newI(null, \"\");  // 创建全局的 I，共测试程序使用\n  I.path = location.pathname;\n\n  global.addEventListener(\"load\", async function () {\n    if (cases)\n      try {\n        var tests = cases.split(\",\");\n        for (var i = 0; i < tests.length; i++)\n          await execScript(tests[i]);\n        await I.run();\n        var errs = errors(I);\n      }\n      catch (e) {\n        log(\"#eUncaught %s: %s\", e.name, e.message);\n        errs = -1;\n      }\n      finally {\n        if (!debug) {\n          server(\"exit\", errs);\n          this.close();\n        }\n      }\n    else {\n      await I.run();\n      var errs = errors(I);\n      if (errs) {\n        log(\"#eTOTAL ERRORS: %d !\", errs)\n      }\n      else {\n        log(\"#sALL SUCCESSFUL!\")\n      }\n    }\n\n  });\n\n  async function execScript(src) {\n    return new Promise(function (resolve) {\n      var script = document.createElement(\"script\");\n      script.onload = resolve;\n      script.src = src;\n      try { document.head.appendChild(script) }\n      finally { if(!debug) document.head.removeChild(script) }\n    });\n  }\n})(0, 0, Function, Object, String, Array, RegExp, Date, Error, Promise);\n";
const auto = /*AUTOJS*/"(function(){\n  const cases=\"\";\n  this.addEventListener(\"load\", function(){\n    var tests = cases.split(\",\");\n    var body = document.body;\n    for(var i=0, test; test=tests[i]; i++) {\n      var script = document.createElement(\"script\");\n      script.setAttribute(\"src\", test);\n      body.appendChild(script);\n    }\n    // script = document.createElement(\"script\");\n    // script.text = \"I.run()\";\n    // body.appendChild(script);\n    script.addEventListener(\"load\", function(){\n      I.run();\n    });\n  });\n})();";

function Server(agent, page, tests) {
  var http = require("http");
  var fs = require("fs");
  var path = require("path");
  var cwd = process.cwd() + "/";

  var mime = {
    ".js": "text/javascript; charset=utf-8",
    ".html": "text/html; charset=utf-8"
  };

  var operates = {
    log: console.log.bind(console),
    exit: process.exit.bind(process)
  }

  var server = http.createServer(service);

  server.on("clientError", function (err) {
    log("#eclientError: %s", err.code);
  });

  server.listen(8080, function () {
    server.port = server.address().port;
    console.log("Web Server running at http://localhost:" + server.port + "/");
  });

  const agents = {
    default: "open ",
    chrome: 'open -a "/Applications/Google Chrome.app" -n --args ',
    firefox: "open -a Firefox ",
    opera: "open -a Opera ",
    safari: "open -a Safari "
  };

  var agent = agents[agent] || "open ";

  var command = agent + "http://localhost:8080/" + (page || "") + "?test=" + tests.join(",");
  const exec = require("child_process").exec;
  exec(command);

  function service(req, res) {
    var url = req.url.slice(1), headers = req.headers;
    if (url == "/") {
      res.end();
      var oper = headers.oper;
      if (operate = operates[oper]) {
        operate(decodeURIComponent(headers.value));
      }
      else {
        console.error("Unknown oper:", oper);
      }
      return;
    }
    if (url === "it.js") {
      res.setHeader("Content-Type", "text/javascript; charset=utf-8");
      return res.end(it);
    }
    if (url === "favicon.ico")
      return res.end();
    try {
      var segs = url.split('?');
      url = segs[0];
      if (headers.referer) {
        var type = mime[path.extname(url)];
        if (type)
          res.setHeader("Content-Type", type);
        if (url.endsWith(".js")) {
          segs = macro("./" + url, cwd, { AGENT: 1 });
        }
        else {
          segs = fs.readFileSync(url);
        }
        res.write(segs);
        res.end();
      }
      else {
        res.setHeader("Content-Type", "text/html; charset=utf-8");
        var qry = segs[1];
        if (qry) {
          segs = qry.split("&");
          for (var i = 0; i < segs.length; i++) {
            qry = segs[i];
            if (qry.startsWith("test="))
              break;
          }
          if (i < segs.length)
            var tests = qry.slice(5);
        }
        if (tests) {
          res.write('<script src="/it.js" tests="' + tests + '" ' + debug + '></script>\n');
        }
        if (url)
          res.write(fs.readFileSync(url));
        res.end();
      }
    }
    catch (e) {
      res.statusCode = 500;
      res.statusMessage = e.message;
      res.end();
      log("#e%s", e.message);
    }
  }

};


var argv = process.argv.slice(2), agent, page, tests = [], debug;

for (var i = 0, arg; arg = argv[i]; i++) {
  if (arg === '-debug') {
    debug = "debug";
  }
  else if (arg[0] === '-') {
    if (agent) help();
    agent = arg.slice(1);
  }
  else if (arg.endsWith(".html")) {
    if (page) help();
    page = arg;
  }
  else {
    tests.push(arg);
  }
}

if (!tests.length && !page) help();

if (agent || page) {  // 服务器远端测试
  Server(agent, page, tests);
}
else {   // nodejs 环境中测试
  global.require = require;
  global.I = newI(null, "");
  const path = require("path");
  const fs = require("fs");
  const cwd = process.cwd();
  for (var i = 0; i < tests.length; i++) {
    var test = I.path = path.resolve(cwd, tests[i]);
    var code = macro(test, cwd + "/", { OS: 1 });
    code += "\n//# sourceURL=" + test;
    cachedRows[test] = code.split("\n");
    global.eval(code);
  }
  process.nextTick(main);
}

//const PACKAGE = "{\n  \"name\": \"ihope\",\n  \"version\": \"0.1.14\",\n  \"description\": \"JavaScript Testing Libaray\",\n  \"keywords\": [\n    \"ihope\",\n    \"test\"\n  ],\n  \"license\": \"MIT\",\n  \"author\": {\n    \"name\": \"李战(leadzen)\",\n    \"email\": \"leadzen@qq.com\"\n  },\n  \"bin\": {\n    \"it\": \"bin/it\"\n  },\n  \"main\": \"dist/ihope.js\",\n  \"files\": [\n    \"dist/ihope.js\",\n    \"it.js\",\n    \"bin/it\"\n  ],\n  \"devDependencies\": {\n    \"macrojs\": \"^0.1.6\",\n    \"uglify-js\": \"^3.1.0\"\n  },\n  \"scripts\": {\n    \"build\": \"mjc src/ihope.js dist/ihope.js && mjc src/it.js it.js && mjc src/it bin/it\",\n    \"publish\": \"npm run build\"\n  }\n}\n"
//const VERSION = "0.1.14"
function help() {
  log("JavaScript Test Runner ("+/*VERSION*/"0.1.14"+")\n    Usage:  it [-<agent>] [-debug] [page.html] test.js");
  process.exit(-1);
}
